# The awning motor is controlled by two relays to set the motor direction.
# relay1     relay2    motor     state
# off        off       -  -      stopped
# on         off       +  -      opening
# off        on        -  +      closing
# on         on        +  +      stopped

# Relay common values should be attached to the motor power.
# Ground is attached to the normally closed pin of both relays.
# Positive voltage is attached to the normally open pin of both relays.

substitutions:
  cover_name: "Default Cover"
  cover_id: default_cover_id
  current_sensor_id: 
  current_sensor_parent_id: 
  relay_1_id: relay_1
  relay_2_id: relay_2
  current_update_interval_ms: "100"  # How often to update current sensor during operation (milliseconds)

number:
  - platform: template
    name: ${cover_name} Open Duration
    id: ${cover_id}_open_duration_number
    min_value: 5
    max_value: 300
    step: 0.5
    unit_of_measurement: "s"
    icon: "mdi:timer-sand"
    optimistic: true
    initial_value: 30
    restore_value: true
    entity_category: config

  - platform: template
    name: ${cover_name} Close Duration
    id: ${cover_id}_close_duration_number
    min_value: 5
    max_value: 300
    step: 0.5
    unit_of_measurement: "s"
    icon: "mdi:timer-sand"
    optimistic: true
    initial_value: 30
    restore_value: true
    entity_category: config

cover:
  - platform: current_based
    name: ${cover_name}
    id: ${cover_id}
    device_class: awning

    open_action:
      - logger.log: "Opening cover ${cover_name}, turn off ${relay_2_id}, turn on ${relay_1_id}"
      - script.execute: ${cover_id}_update_current_sensor_script
      - switch.turn_off: ${relay_2_id}
      - switch.turn_on: ${relay_1_id}

    open_duration: !lambda "return id(${cover_id}_open_duration_number).state * 1000;"

    open_moving_current_threshold: 0.5
    open_obstacle_current_threshold: 3.5
    open_sensor: ${current_sensor_id}

    close_action:
      - logger.log: "Closing cover ${cover_name}, turn off ${relay_2_id}, turn on ${relay_1_id}"
      - script.execute: ${cover_id}_update_current_sensor_script
      - switch.turn_off: ${relay_1_id}
      - switch.turn_on: ${relay_2_id}

    close_duration: !lambda "return id(${cover_id}_close_duration_number).state * 1000;"

    stop_action:
      - logger.log: "Stop cover ${cover_name}, turn off ${relay_2_id}, ${relay_1_id}"
      - switch.turn_off: ${relay_1_id}
      - switch.turn_off: ${relay_2_id}

    close_sensor: ${current_sensor_id}
    close_moving_current_threshold: 0.5
    close_obstacle_current_threshold: 3.5

    malfunction_detection: false
    malfunction_action:
      - logger.log: "Cover ${cover_name} malfunction detected"

    max_duration: !lambda "return (id(${cover_id}_open_duration_number).state > id(${cover_id}_close_duration_number).state ? id(${cover_id}_open_duration_number).state : id(${cover_id}_close_duration_number).state) * 1000;"

script:
  - id: ${cover_id}_update_current_sensor_script
    mode: restart
    then:
      - repeat:
          count: !lambda |-
            // Calculate max duration in iterations (each iteration is ${current_update_interval_ms}ms)
            float max_duration = id(${cover_id}_open_duration_number).state > id(${cover_id}_close_duration_number).state 
              ? id(${cover_id}_open_duration_number).state 
              : id(${cover_id}_close_duration_number).state;
            return (int)(max_duration * 1000 / ${current_update_interval_ms});  // iterations = seconds * 1000ms / interval_ms
          then:
            - if:
                condition:
                  lambda: |-
                    auto state = id(${cover_id}).current_operation;
                    return state == COVER_OPERATION_OPENING || state == COVER_OPERATION_CLOSING;
                then:
                  - component.update: ${current_sensor_parent_id}
                  - delay: ${current_update_interval_ms}ms
                else:
                  - script.stop: ${cover_id}_update_current_sensor_script
