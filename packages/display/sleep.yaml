substitutions:
  sleep_idle_time_milliseconds: 5000

globals:
  - id: last_input_ms
    type: uint32_t
    restore_value: no
    initial_value: "0"

  - id: screen_is_off
    type: bool
    restore_value: no

  - id: keep_display_awake
    type: bool
    restore_value: yes
    initial_value: "false"

interval:
  - interval: 1s
    then:
      - lambda: |-
          const uint32_t now = millis();
          // Initialize at boot
          if (id(last_input_ms) == 0) id(last_input_ms) = now;

          const uint32_t idle_ms = now - id(last_input_ms);
          // Don't turn off if user explicitly wants to keep the display awake
          if (!id(screen_is_off) && !id(keep_display_awake) && idle_ms > (uint32_t) atoi("${sleep_idle_time_milliseconds}")) {
            id(enter_screen_off).execute();
          }

script:
  # Call whenever user interacts (touch / button)
  - id: screen_bump_activity
    then:
      - lambda: |-
          id(last_input_ms) = millis();
      - if:
          condition:
            lambda: 'return id(screen_is_off);'
          then:
            - script.execute: exit_screen_off

  # Turn off: pick A or B or both
  - id: enter_screen_off
    then:
      # Optionally tell LVGL to go to sleep (reduces CPU draw)
      - lvgl.sleep.enable
      # Option A: cut panel EN
      - if:
          condition:
            lambda: 'return true;'  # set false if you don't use EN
          then:
            - switch.turn_off: panel_power
      # Option B: panel sleep via display action
      - if:
          condition:
            lambda: 'return true;'  # set false if you don't use display actions
          then:
            - display.turn_off: disp
      - lambda: |-
          id(screen_is_off) = true;

  # Turn on again (first tap wakes; second tap interacts)
  - id: exit_screen_off
    then:
      # Power first (if using EN)
      - if:
          condition:
            lambda: 'return true;'  # set false if no EN
          then:
            - switch.turn_on: panel_power
            - delay: 60ms   # give panel rails time to rise
      # Wake panel
      - if:
          condition:
            lambda: 'return true;'  # set false if not using display actions
          then:
            - display.turn_on: disp
      # Re-enable LVGL rendering
      - lvgl.sleep.disable
      # Force a redraw so the first frame is crisp
      - lvgl.redraw
      - lambda: |-
          id(screen_is_off) = false;
          id(last_input_ms) = millis();   // restart the idle timer

switch:
  - platform: template
    name: "Display Keep Awake"
    id: display_keep_awake_switch
    optimistic: true
    restore_state: yes
    turn_on_action:
      - lambda: |-
          id(keep_display_awake) = true;
    turn_off_action:
      - lambda: |-
          id(keep_display_awake) = false;
