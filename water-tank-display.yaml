# The water tank display shows the current level of the water tank as a percentage
# and the number of gallons remaining. It also allows control over the water pump
# (which automatically turns off after a timeout), the pump supply source (dirty water 
# or water tank), and the water fill valve.

substitutions:
  device_name: water_tank_display
  friendly_name: Water Tank Display
  project_name:  Mercedes Sprinter Control Modules
  project_version: "1.0.0"
  log_level: DEBUG

packages:
  remote_packages:
    url: https://github.com/rluengen/esphome
    ref: main
    refresh: always
    files:
      - path: packages/common.yaml
        vars:
          api_encryption_key: !secret encryption_key
      - path: packages/network/wifi.yaml
        vars:
          wifi_ssid: !secret wifi_ssid
          wifi_password: !secret wifi_password
      - path: packages/time/homeassistant.yaml
      - path: packages/icons/homeassistant_icons.yaml
      - path: packages/icons/network_icons.yaml
      - path: devices/waveshare-ESP32-S3-Touch-LCD-2.8C.yaml
        vars:
          display_id: round_display_id
          display_backlight_id: display_backlight_id
      # - path: packages/display/sleep.yaml
      #   vars:
      #     display_id: round_display_id
      #     display_panel_power_switch_id: display_backlight_id
      #     sleep_idle_time_milliseconds: 300000

esphome:
  name: ${device_name}
  friendly_name: ${friendly_name}
  project:
    name: smartvan.${project_name}
    version: ${project_version}
  on_boot:
    - valve.close: valve_input_output_hydrant
    - valve.close: valve_water_pump_source
    - valve.close: valve_fill

globals:
  - id: fill_start_time
    type: uint32_t
    restore_value: false

  - id: fill_start_level
    type: float
    restore_value: false

  - id: fill_rate_gpm
    type: float
    restore_value: false
    initial_value: '0.0'

  - id: tank_capacity_in_gallons
    type: float
    restore_value: false
    initial_value: '16.0'  # 16 gallon tank

  - id: pump_timer_remaining
    type: int
    restore_value: false
    initial_value: '0'

number:
  - platform: template
    id: tank_capacity_setting
    name: "Tank Capacity (gallons)"
    min_value: 1
    max_value: 100
    step: 0.5
    initial_value: 16.0
    optimistic: true
    set_action:
      - globals.set:
          id: tank_capacity_in_gallons
          value: !lambda 'return x;'

  - platform: template
    id: pump_timer_duration
    name: "Pump Timer Duration (seconds)"
    min_value: 60
    max_value: 3600
    step: 60
    initial_value: 1200
    optimistic: true
    mode: box
    unit_of_measurement: "s"

display:
  - id: !extend round_display_id
    dimensions:
      height: 466
      width: 472

touchscreen:
  - id: !extend ${touchscreen_id}
    # on_touch:
    #   - script.execute: screen_bump_activity

wifi:
  on_connect:
    - lvgl.label.update:
        id: lbl_wifi_status
        text: "\U000F0928"  # wifi-strength-4 as default when connected
  on_disconnect:
    - lvgl.label.update:
        id: lbl_wifi_status
        text: "\U000F05AA"  # wifi-off

# XL9535 I2C GPIO expander for relay control (using sx1509 component - compatible)
sx1509:
  - id: xl9535_relays
    i2c_id: i2c_bus
    address: 0x24  # Common address for XL9535, may be 0x20, 0x21, 0x24, or 0x27

# Since the board includes only 3 GPIO ports (18, 17, and 16), we either need to use I2C
# or do something else, since we have 3 valves to control, plus the water pump relay, 
# plus the water level input (ADC).

# functionality:
# turn the water pump on/off via manual control or automations based on water level
# display water level on the screen
# turn on drain valve to drain the tank
# rotate the valves to fill from a dirty water source or a clean water source

binary_sensor:
  - platform: template
    id: water_tank_full
    name: "Water Tank Full"
    lambda: |-
      if (isnan(id(tank_percent).state)) return false;
      return id(tank_percent).state >= 95.0f;
    
    on_press:
      then:
        - logger.log: "Tank full - stopping fill operations"
        - script.stop: fresh_water_fill
        - valve.close: valve_fill
        - valve.close: valve_input_output_hydrant

  - platform: template
    id: water_tank_low
    name: "Water Tank Low"
    lambda: |-
      if (isnan(id(tank_percent).state)) return true;
      return id(tank_percent).state <= 5.0f;

    on_press:
      then:
        - if:
            condition:
              and:
                - switch.is_on: water_pump_switch
                - lambda: 'return id(valve_water_pump_source).current_operation == VALVE_OPERATION_OPENING || id(valve_water_pump_source).position == VALVE_OPEN;'
            then:
              - logger.log: "Dry-run protection: Tank too low, stopping pump"
              - switch.turn_off: water_pump_switch
              - script.stop: pump_timer_countdown

  - platform: homeassistant
    id: water_leak_detected
    entity_id: binary_sensor.water_leak
    on_press:
      then:
        - logger.log: "Water leak detected - emergency shutdown"
        - switch.turn_off: water_pump_switch
        - delay: 500ms  # Let pump stop first
        - valve.close: valve_water_pump_source
        - valve.close: valve_input_output_hydrant
        - valve.close: valve_fill
        - script.stop: pump_timer_countdown
        - script.stop: fresh_water_fill
        # - lvgl.label.update:
        #     id: lbl_timer
        #     text: "LEAK!"
        # - lvgl.label.update:
        #     id: lbl_tank_status
        #     text: "Water Leak Detected"

sensor:
#  - platform: adc
#    pin: GPIO4
#    id: water_tank_adc_v
#    attenuation: 12db
#    update_interval: 500ms

  - platform: template
    id: water_tank_adc_v

  # It's a software helper in ESPHome that calculates resistance (in ohms) from an ADC voltage 
  # reading using a known reference resistor in a voltage divider.
  # https://esphome.io/components/sensor/resistance/
  - platform: resistance
    id: sender_ohms
    name: "Fresh Water Sender Resistance (ohms)"
    sensor: water_tank_adc_v  # This is your ADC voltage sensor
    configuration: DOWNSTREAM # Position of unknown resistor in divider
    resistor: 220.0 Ohm # (Required, float): The value of the resistor with a constant value.
    # reference_voltage: 3.3 V # (Optional, float): The reference voltage. Defaults to 3.3V.

    filters:
      # Multi-point calibration for percentage. Add a point for each gallon mark (measured while filling).
      - calibrate_linear:
          - 33.0 -> 0.0    # 33? = 0%
          - 33.0 -> 6.25
          - 33.0 -> 12.5
          - 36.0 -> 18.75
          - 39.0 -> 25.0
          - 43.0 -> 31.25
          - 48.0 -> 37.5
          - 54.0 -> 43.75
          - 61.0 -> 50.0
          - 69.0 -> 56.25
          - 78.0 -> 62.5
          - 89.0 -> 68.75
          - 102.0 -> 75.0
          - 118.0 -> 81.25
          - 137.0 -> 87.5
          - 160.0 -> 93.75
          - 240.0 -> 100.0 # 240? = 100%
      - median:
          window_size: 15
          send_every: 5
      - exponential_moving_average:
          alpha: 0.1
      - clamp:
          min_value: 33.0
          max_value: 240.0

  - platform: template
    id: tank_percent
    name: "Fresh Water Tank Level (%)"
    unit_of_measurement: "%"
    accuracy_decimals: 0
    filters:
      - clamp:
          min_value: 0.0
          max_value: 100.0

    lambda: |-
      // Map your measured ohms to % (example: 33?=100% full, 240?=0% empty)
      if (isnan(id(sender_ohms).state)) return NAN;
      const float ohms = id(sender_ohms).state;
      const float full_ohms  = 33.0f;
      const float empty_ohms = 240.0f;
      float pct = (empty_ohms - ohms) * 100.0f / (empty_ohms - full_ohms);
      if (pct < 0)   pct = 0;
      if (pct > 100) pct = 100;
      return roundf(pct);

    on_value:
      then:
        - lambda: |-
            float gallons = NAN;
            if (!isnan(id(tank_percent).state))
            {
              gallons = id(tank_capacity_in_gallons) * (id(tank_percent).state / 100.0f);
            }
            id(tank_gallons).publish_state(gallons);

        - lvgl.arc.update:
            id: tank_arc
            value: !lambda |-
              if (isnan(x))
              {
                return 0.0;
              }
              return x;

        - lvgl.label.update:
            id: lbl_tank_percent
            text: !lambda |-
              static char buf[16];
              if (isnan(x))
              {
              snprintf(buf, sizeof(buf), "-.- %%");
              }
              else
              {
                snprintf(buf, sizeof(buf), "%.0f %%", x);
              }
              return buf;

        - lvgl.label.update:
            id: lbl_tank_status
            text: !lambda |-
              if (isnan(x)) return "Unknown";
              else if (x >= 95.0) return "Full";
              else if (x >= 75.0) return "High";
              else if (x >= 50.0) return "Medium";
              else if (x >= 25.0) return "Low";
              else if (x >= 10.0) return "Very Low";
              else return "Empty";

        - lvgl.arc.update:
            id: tank_arc
            arc_color: !lambda |-
              if (isnan(x)) return lv_color_hex(0x7F7F7F);            // Gray - Unknown
              else if (x >= 95.0) return lv_color_hex(0x00FF00);      // Green - Full
              else if (x >= 75.0) return lv_color_hex(0x00FF00);      // Green - High
              else if (x >= 50.0) return lv_color_hex(0x0080FF);      // Blue - Medium
              else if (x >= 25.0) return lv_color_hex(0xFFAA00);      // Orange - Low
              else return lv_color_hex(0xFF0000);                     // Red - Very Low

  - platform: template
    id: tank_gallons
    name: "Tank Gallons Remaining"
    unit_of_measurement: "gal"
    accuracy_decimals: 1
    on_value:
      then:
        - lvgl.label.update:
            id: lbl_tank_gallons
            text: !lambda |-
              static char buf[16];
              if (isnan(id(tank_percent).state))
              {
                snprintf(buf, sizeof(buf), "-.- gal", x);
              }
              else
              {
                snprintf(buf, sizeof(buf), "%.1f gal", x);
              }
              return buf;

  - platform: template
    id: estimated_time_to_fill
    name: "Estimated Time to Fill"
    unit_of_measurement: "min"
    accuracy_decimals: 1
    lambda: |-
      if (id(fill_rate_gpm) <= 0.0 || isnan(id(tank_percent).state)) return NAN;
      
      float remaining_gallons = id(tank_capacity_in_gallons) * (100.0 - id(tank_percent).state) / 100.0;
      float minutes = remaining_gallons / id(fill_rate_gpm);
      return minutes;

  # Extend wifi_rssi sensor to update the WiFi icon
  - id: !extend wifi_rssi
    on_value:
      - lvgl.label.update:
          id: lbl_wifi_status
          text: !lambda |-
            if (isnan(x)) {
              return "\U000F05AA";  // wifi-off
            }
            int bars = 0;
            if (x > -55) bars = 4;
            else if (x > -65) bars = 3;
            else if (x > -72) bars = 2;
            else if (x > -80) bars = 1;
            
            if (bars == 4) return "\U000F0928";  // wifi-strength-4
            else if (bars == 3) return "\U000F0925";  // wifi-strength-3
            else if (bars == 2) return "\U000F0922";  // wifi-strength-2
            else if (bars == 1) return "\U000F091F";  // wifi-strength-1
            else return "\U000F05AA";  // wifi-off
      - lvgl.label.update:
          id: lbl_wifi_status
          text_color: !lambda |-
            if (isnan(x)) {
              return lv_color_hex(0x888888);  // Gray for disconnected
            }
            return lv_color_hex(0xFFFFFF);

# https://pictogrammers.com/library/mdi/

# https://esphome.io/components/valve/template/
# Requires Home Assistant 2024.5 or later to use valves.
valve:
  # The valve which controls the external hydrant being used.
  # Closed (default) = Hydrant Out
  # Open = Hydrant in (Fresh Fill)
  - platform: template
    device_class: water
    id: valve_input_output_hydrant
    name: "Input Hydrant Selection Valve"
    icon: "mdi:valve"
    lambda: |-
      return {};
    open_action:
      - logger.log: "Input Selection Valve Opening"
      - switch.turn_on: relay_hydrant_valve
      - valve.template.publish:
          id: valve_input_output_hydrant
          current_operation: OPENING
      - delay: 4s  # Valve actuation time
      - valve.template.publish:
          id: valve_input_output_hydrant
          current_operation: IDLE
          position: !lambda "return VALVE_OPEN;"
      - lvgl.label.update:
          id: lbl_valve_hydrant
          text: "\U000F1068"
      - logger.log: "Input Selection Valve Opened"
    close_action:
      - logger.log: "Input Selection Valve Closing"
      - switch.turn_off: relay_hydrant_valve
      - valve.template.publish:
          id: valve_input_output_hydrant
          current_operation: CLOSING
      - delay: 4s  # Valve actuation time
      - valve.template.publish:
          id: valve_input_output_hydrant
          current_operation: IDLE
          position: !lambda "return VALVE_CLOSED;"
      - lvgl.label.update:
          id: lbl_valve_hydrant
          text: "\U000F1067"
      - logger.log: "Input Selection Valve Closed"
    assumed_state: false
    optimistic: false
    has_position: true

  # The valve which controls the input to the water pump. This is either
  # the water tank or the external (dirty) fill port.
  # Closed (default) = Dirty Water Fill Port
  # Open = Water Tank
  - platform: template
    device_class: water
    id: valve_water_pump_source
    name: "Water Pump Source Selector Valve"
    icon: "mdi:valve"
    lambda: |-
      return {};
    open_action:
      - logger.log: "Water Pump Source Valve Opening"
      - switch.turn_on: relay_source_valve
      - valve.template.publish:
          id: valve_water_pump_source
          current_operation: OPENING
      - valve.close: valve_fill
      - delay: 4s  # Valve actuation time
      - valve.template.publish:
          id: valve_water_pump_source
          current_operation: IDLE
          position: !lambda "return VALVE_OPEN;"
      - lvgl.label.update:
          id: lbl_valve_source
          text: "\U000F1068"
      - logger.log: "Water Pump Source Valve Opened"
    close_action:
      - logger.log: "Water Pump Source Valve Closing"
      - switch.turn_off: relay_source_valve
      - valve.template.publish:
          id: valve_water_pump_source
          current_operation: CLOSING
      - delay: 4s  # Valve actuation time
      - valve.template.publish:
          id: valve_water_pump_source
          current_operation: IDLE
          position: !lambda "return VALVE_CLOSED;"
      - lvgl.label.update:
          id: lbl_valve_source
          text: "\U000F1067"
      - logger.log: "Water Pump Source Valve Closed"
    assumed_state: false
    optimistic: false
    has_position: true

# The water fill valve controls if water is pumped into the water tank.
# This should not be an option if the water source is the water tank.
# Closed (default) = no fill
# Open = Fill Water Tank from Water Pump
  - platform: template
    device_class: water
    id: valve_fill
    name: "Tank Fill Valve"
    icon: "mdi:valve"
    lambda: |-
      return {};
    open_action:
      - logger.log: "Tank Fill Valve Opening"
      - switch.turn_on: relay_fill_valve
      - valve.template.publish:
          id: valve_fill
          current_operation: OPENING
      - delay: 4s  # Valve actuation time
      - valve.template.publish:
          id: valve_fill
          current_operation: IDLE
          position: !lambda "return VALVE_OPEN;"
      - lvgl.label.update:
          id: lbl_valve_fill
          text: "\U000F1068"
      - logger.log: "Tank Fill Valve Opened"
    close_action:
      - logger.log: "Tank Fill Valve Closing"
      - switch.turn_off: relay_fill_valve
      - valve.template.publish:
          id: valve_fill
          current_operation: CLOSING
      - delay: 4s  # Valve actuation time
      - valve.template.publish:
          id: valve_fill
          current_operation: IDLE
          position: !lambda "return VALVE_CLOSED;"
      - lvgl.label.update:
          id: lbl_valve_fill
          text: "\U000F1067"
      - logger.log: "Tank Fill Valve Closed"
    assumed_state: false
    optimistic: false
    has_position: true

switch:
  - platform: template
    id: water_pump_switch
    name: "Water Pump"
    turn_on_action:
      - script.execute: turn_on_water_pump
      - lvgl.label.update:
          id: lbl_pump_status
          text: "\U000F1036"  # pump-on icon
          text_color: 0x00BFFF  # Deep sky blue for running

    turn_off_action:
      - valve.close: valve_water_pump_source
      - valve.close: valve_input_output_hydrant
      - lvgl.label.update:
          id: lbl_pump_status
          text: "\U000F1037"  # pump-off icon
          text_color: 0x888888  # Gray for off

  # XL9535 relay outputs
  - platform: gpio
    id: relay_hydrant_valve
    name: "Hydrant Valve Relay"
    internal: true
    pin:
      sx1509: xl9535_relays
      number: 0
      mode: OUTPUT
      inverted: false

  - platform: gpio
    id: relay_source_valve
    name: "Source Valve Relay"
    internal: true
    pin:
      sx1509: xl9535_relays
      number: 1
      mode: OUTPUT
      inverted: false

  - platform: gpio
    id: relay_fill_valve
    name: "Fill Valve Relay"
    internal: true
    pin:
      sx1509: xl9535_relays
      number: 2
      mode: OUTPUT
      inverted: false

  - platform: gpio
    id: relay_water_pump
    name: "Water Pump Relay"
    internal: true
    pin:
      sx1509: xl9535_relays
      number: 3
      mode: OUTPUT
      inverted: false

#    open_action:
#      - switch.turn_on: relay_fill_open
#    close_action:
#      - switch.turn_off: relay_fill_open

#switch:
#  - platform: gpio
#    id: valve_open
#    name: "Valve OPEN relay"
#    pin: GPIO10
#    interlock: [valve_open, valve_close]
#    interlock_wait_time: 100ms
#
#  - platform: gpio
#    id: valve_close
#    name: "Valve CLOSE relay"
#    pin: GPIO11
#    interlock: [valve_open, valve_close]
#    interlock_wait_time: 100ms
#
#  - platform: gpio
#    id: water_pump_relay
#    name: "Water Pump"
#    pin: GPIO12

font:
  - file: "fonts/segoeui.ttf"
    id: f_text_32
    size: 32
    bpp: 4

  - file: "fonts/segoeui.ttf"
    id: f_value_90
    size: 90
    bpp: 4

  - file: "fonts/segoeui.ttf"
    id: f_text_24
    size: 24
    bpp: 4

  - file: "fonts/materialdesignicons-webfont.ttf"
    id: valve_icon_40
    size: 40
    bpp: 4
    glyphs: [
      "\U000F1066", # valve
      "\U000F1067", # valve-closed
      "\U000F1068", # valve-open
      "\U000F1036", # pump
      "\U000F1037", # pump-off
    ]

color:
  - id: background
    hex: '000000'
  - id: text_foreground
    hex: 'FFFFFF'

api:
  on_client_connected:
    - if:
        condition:
          lambda: 'return (0 == client_info.find("Home Assistant "));'
        then:
          - lvgl.widget.show: lbl_connection_status
  on_client_disconnected:
    - if:
        condition:
          lambda: 'return (0 == client_info.find("Home Assistant "));'
        then:
          - lvgl.widget.hide: lbl_connection_status

# https://docs.lvgl.io/master/details/widgets/base_widget.html
lvgl:
  bg_color: 0x000000
  on_idle:
    timeout: 300s
    then:
      - logger.log: "LVGL is idle"

  on_boot:
    then:
      - logger.log: "LVGL boot"
      - lambda: |-
          lv_obj_t* arc = id(tank_arc);
          lv_obj_set_style_arc_width(arc, 35, LV_PART_INDICATOR);   // foreground
          lv_obj_set_style_arc_width(arc, 35, LV_PART_MAIN);        // background
          lv_obj_set_style_arc_color(arc, lv_color_hex(0xFFAA00), LV_PART_MAIN); // background

  touchscreens:
    - touchscreen_id: touch_id
      long_press_time: 400ms
      long_press_repeat_time: 100ms

  top_layer:
    bg_color: 0x000000
    widgets:
      - arc:
          id: tank_arc
          height: 460
          width: 460
          align: CENTER
          arc_width: 35
          arc_color: 0x0080FF
          arc_rounded: true
          value: 0
          min_value: 0
          max_value: 100
          start_angle: 135
          x: 3
          end_angle: 45  # 270 degree arc
          bg_opa: TRANSP
          adjustable: false
          arc_opa: COVER
          clickable: false

      # Tank status label at bottom
      - label:
          id: lbl_tank_status
          text: ""
          align: BOTTOM_MID
          y: -15
          text_font: f_text_32
          text_color: 0x888888
          text_align: CENTER

      # Status icons row above tank status
      - label:
          id: lbl_connection_status
          align: BOTTOM_LEFT
          x: 20
          y: -60
          text_align: LEFT
          text_font: homeassistant_icons
          text: "\U000F07D0"
          text_color: 0x03A9F4 # Blue color for Home Assistant icon
          clickable: false

      - label:
          id: lbl_wifi_status
          text: "\U000F05AA"  # wifi-off icon by default
          align: BOTTOM_LEFT
          x: 80
          y: -60
          text_font: wifi_icons
          text_color: 0x888888  # Gray for disconnected
          text_align: LEFT
          clickable: false

      - label:
          id: lbl_valve_hydrant
          text: "\U000F1066"
          align: BOTTOM_LEFT
          x: 130
          y: -60
          text_font: valve_icon_40
          text_color: 0x00CED1  # Turquoise for hydrant
          text_align: LEFT
          clickable: false

      - label:
          id: lbl_valve_source
          text: "\U000F1066"
          align: BOTTOM_LEFT
          x: 190
          y: -60
          text_font: valve_icon_40
          text_color: 0x888888  # Gray for source
          text_align: LEFT
          clickable: false

      - label:
          id: lbl_valve_fill
          text: "\U000F1066"
          align: BOTTOM_LEFT
          x: 250
          y: -60
          text_font: valve_icon_40
          text_color: 0x00FF00  # Green for fill
          text_align: LEFT
          clickable: false

      - label:
          id: lbl_pump_status
          text: "\U000F1037"  # pump-off icon by default
          align: BOTTOM_LEFT
          x: 310
          y: -60
          text_font: valve_icon_40
          text_color: 0x888888  # Gray for off
          text_align: LEFT
          clickable: false

  widgets:
    - obj:
        align: CENTER
        height: 100%
        width: 100%
        bg_color: 0x000000
        on_click:
          then:
            - logger.log: "Pump switch clicked"
            - if:
                condition:
                  switch.is_on: water_pump_switch
                then:
                  - logger.log: "Water pump is on, turning off"
                  - script.stop: pump_timer_countdown
                  - switch.turn_off: water_pump_switch
                  - lvgl.label.update:
                      id: lbl_timer
                      text: ""
                  - lvgl.widget.hide: lbl_timer
                else:
                  - logger.log: "Water pump is off, turning on"
                  - script.execute: turn_on_water_pump

        widgets:
        - roller:
            align: CENTER
            id: roller_id
            options:
                - Run
                - Fresh Fill
                - Dirty Fill
            bg_color: 0x000000
            text_color: 0xFFFFFF
            border_width: 0
            on_change:
                then:
                - logger.log: "Roller changed to new value"
                - lvgl.label.update:
                    id: lbl_timer
                    text: ""
                - lvgl.widget.hide: lbl_timer

        # Center gallons display
        - label:
            id: lbl_tank_gallons
            text: "-.- gal"
            align: CENTER
            y: -15
            text_font: f_value_90
            text_color: 0xFFFFFF
            text_align: CENTER
            clickable: false

        # Percentage display below
        - label:
            id: lbl_tank_percent
            text: "- %"
            align: CENTER
            y: 80
            text_font: f_text_32
            text_color: 0xAAAAAA
            text_align: CENTER
            clickable: false

        # Timer countdown display - visible when pump is running
        - label:
            id: lbl_timer
            text: ""
            align: TOP_MID
            y: 50
            text_font: f_text_24
            text_color: 0xFFAA00
            text_align: CENTER
            clickable: false
            hidden: true  # Hide by default, show only during countdown
            
script:
  - id: turn_on_water_pump
    mode: restart
    then:
      # Check for dry-run condition before starting pump
      - if:
          condition:
            binary_sensor.is_on: water_tank_low
          then:
            - logger.log: "Cannot start pump - tank too low for dry-run protection"
            # replace with the icon: https://pictogrammers.com/library/mdi/icon/water-off/
            - lvgl.label.update:
                id: lbl_timer
                text: "Tank Low!"
            - delay: 3s
            # - lvgl.label.update:
            #     id: lbl_timer
            #     text: ""
            - script.stop: turn_on_water_pump
          else:
            - valve.open: valve_water_pump_source
            - valve.open: valve_input_output_hydrant
            - switch.turn_on: relay_water_pump
            - switch.turn_on: water_pump_switch

  - id: turn_off_water_pump
    then:
      - switch.turn_off: relay_water_pump
      - switch.turn_off: water_pump_switch
      - delay: 500ms  # Wait for pump to stop before closing valves
      - valve.close: valve_water_pump_source
      - valve.close: valve_input_output_hydrant

  - id: fresh_water_fill
    then:
      - if:
          condition:
            binary_sensor.is_off: water_tank_full
          then:
            # Record start conditions
            - lambda: |-
                id(fill_start_time) = millis();
                id(fill_start_level) = id(tank_percent).state;

            - valve.close: valve_water_pump_source
            - valve.close: valve_fill
            - valve.open: valve_input_output_hydrant

            # Monitor and update fill rate every second until it is full, timing out at 30 minutes
            - repeat:
                count: 1800 # 30 minutes * 60 seconds
                then:
                  - delay: 1s

                  # Check if tank is full and auto-stop (check first to exit early)
                  - if:
                      condition:
                        binary_sensor.is_on: water_tank_full
                      then:
                        - logger.log: "Tank full - auto-stopping pump"
                        - switch.turn_off: water_pump_switch
                        # - lvgl.label.update:
                        #     id: lbl_timer
                        #     text: "Tank Full"
                        - delay: 3s
                        # - lvgl.label.update:
                        #     id: lbl_timer
                        #     text: ""
                        # - lvgl.label.update:
                        #     id: lbl_fresh_water_fill
                        #     text: "Fresh Water Fill"
                        - script.stop: pump_timer_countdown
                        - script.stop: fresh_water_fill

                  - lambda: |-
                      // Calculate fill rate in gallons per minute
                      uint32_t elapsed_ms = millis() - id(fill_start_time);
                      float elapsed_min = elapsed_ms / 60000.0;
                      
                      if (elapsed_min > 0.5) {  // Wait at least 30 seconds for accurate reading
                        float level_change = id(tank_percent).state - id(fill_start_level);
                        float gallons_filled = id(tank_capacity_in_gallons) * level_change / 100.0;
                        id(fill_rate_gpm) = gallons_filled / elapsed_min;
                        
                        id(estimated_time_to_fill).publish_state(
                          id(fill_rate_gpm) > 0 ? 
                          (id(tank_capacity_in_gallons) * (100.0 - id(tank_percent).state) / 100.0) / id(fill_rate_gpm) : 
                          NAN
                        );
                      }

                  # Update display with estimate
                  # - lvgl.label.update:
                  #     id: lbl_fresh_water_fill
                  #     text: !lambda |-
                  #       static char buf[64];
                  #       if (id(fill_rate_gpm) > 0.5) {
                  #         float eta = (id(tank_capacity_in_gallons) * (100.0 - id(tank_percent).state) / 100.0) / id(fill_rate_gpm);
                  #         snprintf(buf, sizeof(buf), "Fresh Fill - ETA: %.0f min", eta);
                  #       } else {
                  #         snprintf(buf, sizeof(buf), "Fresh Fill - Calculating...");
                  #       }
                  #       return buf;

  - id: pump_timer_countdown
    mode: restart
    then:
      - lvgl.widget.show: lbl_timer  # Show the timer label
      - lambda: 'id(pump_timer_remaining) = (int)id(pump_timer_duration).state;'
      - while:
          condition:
            lambda: 'return id(pump_timer_remaining) > 0;'
          then:
            - lambda: |-
                int remaining = id(pump_timer_remaining);
                int mins = remaining / 60;
                int secs = remaining % 60;
                char buf[32];
                snprintf(buf, sizeof(buf), "%d:%02d", mins, secs);
                lv_label_set_text(id(lbl_timer), buf);
                id(pump_timer_remaining)--;
            - delay: 1s
      - logger.log: "Pump timer expired - turning off pump"
      - switch.turn_off: water_pump_switch
      - lvgl.label.update:
          id: lbl_timer
          text: ""
      - lvgl.widget.hide: lbl_timer  # Hide the timer label
