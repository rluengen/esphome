# The water tank display shows the current level of the water tank as a percentage
# and the number of gallons remaining. It also allows control over the water pump
# (which automatically turns off after a timeout), the pump supply source (dirty water 
# or water tank), and the water fill valve.

substitutions:
  device_name: water_tank_display
  friendly_name: Water Tank Display
  project_name:  Mercedes Sprinter Control Modules
  project_version: "1.0.0"
  log_level: VERBOSE

packages:
  remote_packages:
    url: https://github.com/rluengen/esphome
    ref: main
    refresh: always
    files:
      - path: packages/common.yaml
        vars:
          api_encryption_key: !secret encryption_key
      - path: packages/network/wifi.yaml
        vars:
          wifi_ssid: !secret wifi_ssid
          wifi_password: !secret wifi_password
      - path: packages/time/homeassistant.yaml
      - path: devices/waveshare-esp32-s3-touch-amoled-1.75.yaml
        vars:
          display_id: round_display_id
          display_backlight_id: display_backlight_id
      - path: packages/display/sleep.yaml
        vars:
          display_id: round_display_id
          display_panel_power_switch_id: display_backlight_id

esphome:
  name: ${device_name}
  friendly_name: ${friendly_name}
  comment: "ESP32-S3 + CO5300 (QSPI) 466x466 + CST9217 touch"
  project:
    name: smartvan.${project_name}
    version: ${project_version}

# Since the board includes only 3 GPIO ports (18, 17, and 16), we either need to use I2C
# or do something else, since we have 3 valves to control, plus the water pump relay, 
# plus the water level input (ADC).

# functionality:
# turn the water pump on/off via manual control or automations based on water level
# display water level on the screen
# turn on drain valve to drain the tank
# rotate the valves to fill from a dirty water source or a clean water source

binary_sensor:
  - platform: template
    id: water_tank_full
    name: "Water Tank Full"
    lambda: |-
      if (isnan(id(tank_percent).state)) return false;
      return id(tank_percent).state >= 95.0f;

sensor:
#  - platform: adc
#    pin: GPIO4
#    id: water_tank_adc_v
#    attenuation: 12db
#    update_interval: 500ms

  - platform: template
    id: water_tank_adc_v

  # It's a software helper in ESPHome that calculates resistance (in ohms) from an ADC voltage 
  # reading using a known reference resistor in a voltage divider.
  # https://esphome.io/components/sensor/resistance/
  - platform: resistance
    id: sender_ohms
    name: "Fresh Water Sender Resistance (ohms)"
    sensor: water_tank_adc_v  # This is your ADC voltage sensor
    configuration: DOWNSTREAM # Position of unknown resistor in divider
    resistor: 220.0 Ohm # (Required, float): The value of the resistor with a constant value.
    # reference_voltage: 3.3 V # (Optional, float): The reference voltage. Defaults to 3.3V.

    filters:
      # Multi-point calibration for percentage. Add a point for each gallon mark (measured while filling).
      - calibrate_linear:
          - 33.0 -> 0.0    # 33? = 0%
          - 33.0 -> 6.25
          - 33.0 -> 12.5
          - 36.0 -> 18.75
          - 39.0 -> 25.0
          - 43.0 -> 31.25
          - 48.0 -> 37.5
          - 54.0 -> 43.75
          - 61.0 -> 50.0
          - 69.0 -> 56.25
          - 78.0 -> 62.5
          - 89.0 -> 68.75
          - 102.0 -> 75.0
          - 118.0 -> 81.25
          - 137.0 -> 87.5
          - 160.0 -> 93.75
          - 240.0 -> 100.0 # 240? = 100%
      - median:
          window_size: 15
          send_every: 5
      - exponential_moving_average:
          alpha: 0.1
      - clamp:
          min_value: 33.0
          max_value: 240.0

  - platform: template
    id: tank_percent
    name: "Fresh Water Tank Level (%)"
    unit_of_measurement: "%"
    accuracy_decimals: 0
    filters:
      - clamp:
          min_value: 0.0
          max_value: 100.0
    lambda: |-
      // Map your measured ohms to % (example: 33?=100% full, 240?=0% empty)
      if (isnan(id(sender_ohms).state)) return NAN;
      const float ohms = id(sender_ohms).state;
      const float full_ohms  = 33.0f;
      const float empty_ohms = 240.0f;
      float pct = (empty_ohms - ohms) * 100.0f / (empty_ohms - full_ohms);
      if (pct < 0)   pct = 0;
      if (pct > 100) pct = 100;
      return roundf(pct);

  - platform: template
    id: tank_gallons
    name: "Tank Gallons Remaining"
    unit_of_measurement: "gal"
    accuracy_decimals: 1
    update_interval: 1s
    lambda: |-
      // Replace with your true tank capacity in gallons
      const float CAPACITY_GAL = 120.0f;
      if (isnan(id(tank_percent).state)) return NAN;
      return CAPACITY_GAL * (id(tank_percent).state / 100.0f);


# https://pictogrammers.com/library/mdi/

# https://esphome.io/components/valve/template/
# Requires Home Assistant 2024.5 or later to use valves.
valve:
  # The valve which controls the external hydrant being used.
  # Closed (default) = Hydrant Out
  # Open = Hydrant in (Fresh Fill)
  - platform: template
    device_class: water
    id: valve_input_output_hydrant
    name: "Input Hydrant Selection Valve"
    icon: "mdi:valve"
    lambda: |-
      return VALVE_CLOSED;
    open_action:
      - logger.log: "Input Selection Valve Opened"
    close_action:
      - logger.log: "Input Selection Valve Closed"
    assumed_state: false

  # The valve which controls the input to the water pump. This is either
  # the water tank or the external (dirty) fill port.
  # Closed (default) = Dirty Water Fill Port
  # Open = Water Tank
  - platform: template
    device_class: water
    id: valve_water_pump_source
    name: "Water Pump Source Selector Valve"
    icon: "mdi:valve"
    lambda: |-
      return VALVE_CLOSED;
    open_action:
      - logger.log: "Input Selection Valve Opened"
      - valve.close: valve_fill
#      - wait_until:
#          valve.is_cosed: valve_fill
    close_action:
      - logger.log: "Input Selection Valve Closed"
    assumed_state: false

# The water fill valve controls if water is pumped into the water tank.
# This should not be an option if the water source is the water tank.
# Closed (default) = no fill
# Open = Fill Water Tank from Water Pump
  - platform: template
    device_class: water
    id: valve_fill
    name: "Tank Fill Valve"
    icon: "mdi:valve"
    lambda: |-
      return VALVE_CLOSED;
    open_action:
      - logger.log: "Input Selection Valve Opened"
      - if:
          condition:
            
          
    close_action:
      - logger.log: "Input Selection Valve Closed"
    assumed_state: false

switch:
  - platform: template
    id: water_pump_switch
    name: "Water Pump"

#    open_action:
#      - switch.turn_on: relay_fill_open
#    close_action:
#      - switch.turn_off: relay_fill_open

#switch:
#  - platform: gpio
#    id: valve_open
#    name: "Valve OPEN relay"
#    pin: GPIO10
#    interlock: [valve_open, valve_close]
#    interlock_wait_time: 100ms
#
#  - platform: gpio
#    id: valve_close
#    name: "Valve CLOSE relay"
#    pin: GPIO11
#    interlock: [valve_open, valve_close]
#    interlock_wait_time: 100ms
#
#  - platform: gpio
#    id: water_pump_relay
#    name: "Water Pump"
#    pin: GPIO12

font:
  - file: "gfonts://Montserrat"
    id: f_text_28
    size: 28
    bpp: 4
  - file: "gfonts://Montserrat"
    id: f_value_64
    size: 64
    bpp: 4

color:
  - id: background
    hex: '000000'

# https://docs.lvgl.io/master/details/widgets/base_widget.html
lvgl:
  pages:
    - id: main_page
      bg_color: background
      scrollbar_mode: "OFF"
      widgets:
        - meter:
            align: CENTER

        - label:
            text: "--.- %"
            align: CENTER

        - label:
            text: "-- gal"
            align: CENTER

script:
  - id: turn_on_water_pump
    then:
      - valve.open: valve_water_pump_source
      - valve.open: valve_input_output_hydrant
      - switch.turn_on: water_pump_switch

  - id: turn_off_water_pump
    then:
      - valve.close: valve_water_pump_source
      - valve.close: valve_input_output_hydrant
      - switch.turn_off: water_pump_switch

  - id: fresh_water_fill
    then:
      - if:
          condition:
            binary_sensor.is_off: water_tank_full
          then:
            - valve.close: valve_water_pump_source
            - valve.close: valve_fill
            - valve.open: valve_input_output_hydrant
