# https://www.waveshare.com/esp32-s3-touch-amoled-1.75.htm
# https://devices.esphome.io/devices/waveshare-esp32-s3-touch-amoled-1.75/

substitutions:
  device_name: water-tank-display
  friendly_name: Water Tank Display Controller

# PCF85063 RTC Chip
# QMI8658 IMU Chip
# CO5300 1.75" 466x466 AMOLED Display with CST9217 Touch Controller
# AXP2101 Power Management IC

# Since the board includes only 3 GPIO ports (18, 17, and 16), we either need to use I2C
# or do something else, since we have 3 valves to control (2 relays per reversing valve, 1 relay for auto-reverse valve),
# plus the water pump relay, plus the water level input (ADC).


# functionality:
# turn the water pump on/off via manual control or automations based on water level
# display water level on the screen
# turn on drain valve to drain the tank
# rotate the valves to fill from a dirty water source or a clean water source


# The 2.54mm 8 pin header connectors on the back of the display include:
# GPIO18    GPIO17    GPIO16    RXD     TXD     3v3     GND   EN      GPIO39    VBUS

# MX1.25 BAT - expects voltage input from a battery, 3.7V lithium


sensor:
  - platform: adc
    pin: GPIO4
    id: water_tank_adc_v
    attenuation: 11db
    update_interval: 500ms

  # It�s a software helper in ESPHome that calculates resistance (in ohms) from an ADC voltage reading using a known reference resistor in a voltage divider.
  # https://esphome.io/components/sensor/resistance/
  - platform: resistance
    id: sender_ohms
    name: "Fresh Water Sender Resistance (ohms)"
    sensor: water_tank_adc_v  # This is your ADC voltage sensor
    configuration: DOWNSTREAM # Position of unknown resistor in divider
    resistor: 220.0 Ohm # (Required, float): The value of the resistor with a constant value.
    # reference_voltage: 3.3 V # (Optional, float): The reference voltage. Defaults to 3.3V.

    filters:
      # Multi-point calibration for percentage. Add a point for each gallon mark (measured while filling).
      - calibrate_linear:
          - 33.0 -> 0.0    # 33? = 0%
          - 33.0 -> 6.25
          - 33.0 -> 12.5
          - 36.0 -> 18.75
          - 39.0 -> 25.0
          - 43.0 -> 31.25
          - 48.0 -> 37.5
          - 54.0 -> 43.75
          - 61.0 -> 50.0
          - 69.0 -> 56.25
          - 78.0 -> 62.5
          - 89.0 -> 68.75
          - 102.0 -> 75.0
          - 118.0 -> 81.25
          - 137.0 -> 87.5
          - 160.0 -> 93.75
          - 240.0 -> 100.0 # 240? = 100%
      - median:
          window_size: 15
          send_every: 5s
      - exponential_moving_average:
          alpha: 0.1
      - clamp:
          min_value: 33.0
          max_value: 240.0


  - platform: template
    id: tank_percent
    name: "Fresh Water Tank Level (%)"
    unit_of_measurement: "%"
    accuracy_decimals: 0
    filters:
      - clamp:
          min_value: 0.0
          max_value: 100.0
    lambda: |-
      // Map your measured ohms to % (example: 33?=100% full, 240?=0% empty)
      if (isnan(id(sender_ohms).state)) return NAN;
      const float ohms = id(sender_ohms).state;
      const float full_ohms  = 33.0f;
      const float empty_ohms = 240.0f;
      float pct = (empty_ohms - ohms) * 100.0f / (empty_ohms - full_ohms);
      if (pct < 0)   pct = 0;
      if (pct > 100) pct = 100;
      return roundf(pct);


  - platform: template
    id: tank_gallons
    name: "Tank Gallons Remaining"
    unit_of_measurement: "gal"
    accuracy_decimals: 1
    update_interval: 1s
    lambda: |-
      // Replace with your true tank capacity in gallons
      const float CAPACITY_GAL = 120.0f;
      if (isnan(id(tank_percent).state)) return NAN;
      return CAPACITY_GAL * (id(tank_percent).state / 100.0f);

  - platform: template
    id: water_tank_full
    name: "Water Tank Full"
    lambda: |-
      if (isnan(id(tank_percent).state)) return false;
      return id(tank_percent).state >= 95.0f;


script:
  - id: fill_fresh
    then:
      - if:
          condition:
            binary_sensor.is_off: near_full
          then:
            - cover.open: valve_A
            - delay: 200ms
            - cover.open: valve_B
            - switch.turn_on: valve_C
          else:

packages:
  remote_packages:
    url: https://github.com/rluengen/esphome
    ref: main
    refresh: always
    files:
      - path: packages/common.yaml
        vars:
          api_encryption_key: !secret encryption_key
      - path: packages/network/wifi.yaml
        vars:
          wifi_ssid: !secret wifi_ssid
          wifi_password: !secret wifi_password
      - path: packages/time/homeassistant.yaml
      - path: packages/display/sleep.yaml
      - path: devices/esp32-s3-touch-amoled-1.75.yaml

esphome:
  name: ${device_name}
  friendly_name: ${friendly_name}
  comment: "ESP32-S3 + CO5300 (QSPI) 466x466 + CST9217 touch"
  project:
    name: "waveshare.esp32-s3-touch-amoled-1_75"
    version: "1.0"
  platformio_options:
    board_build.flash_mode: dio
    board_build.f_flash: 80000000L
    board_build.f_cpu: 240000000L

touchscreen:
  - id: !extend ${touchscreen}
    on_touch:
      - script.execute: screen_bump_activity

# https://pictogrammers.com/library/mdi/

# Requires Home Assistant 2024.5 or later to use valves.
valve:
  # The valve which controls the external hydrant being used for input vs output.
  - platform: template
    id: valve_input_output_hydrant
    name: "Input Hydrant Selection Valve"
    comment: "Selects the hydrant between either water input or output."
    device_class: "water"
    icon: "mdi:valve"

  # The valve which controls the input to the water pump from the tank or fill port.
  - platform: template
    id: valve_water_pump_source
    name: "Water Pump Source Selector Valve"
    comment: "Selects the water pump source between tank or fill port."
    device_class: "water"
    icon: "mdi:valve"


  - platform: template
    id: valve_fill
    name: "Tank Fill Valve"
    comment: "Opens the valve to fill the water tank from the water pump."
    device_class: "water"
    icon: "mdi:valve"

    open_action:
      - switch.turn_on: relay_fill_open
    close_action:
      - switch.turn_off: relay_fill_open



switch:
  - platform: gpio
    id: valve_open
    name: "Valve OPEN relay"
    pin: GPIO10
    interlock: [valve_open, valve_close]
    interlock_wait_time: 100ms

  - platform: gpio
    id: valve_close
    name: "Valve CLOSE relay"
    pin: GPIO11
    interlock: [valve_open, valve_close]
    interlock_wait_time: 100ms


  - platform: gpio
    id: water_pump_relay
    name: "Water Pump"
    comment: "Controls power to the water pump"
    pin: GPIO12



# --- Resistive sender ? ADC (example wiring) ---
# Wire the unknown sensor resistance (R_sensor) as a divider with a known R_fixed to 3.3V.
# Read the midpoint on an ADC-capable pin.
sensor:
  - platform: adc
    id: adc_water
    pin: GPIO1              # <-- pick a real ADC pin on your S3
    attenuation: 11db       # gives up to ~3.3V reading range
    update_interval: 1s
    filters:
      - median:
          window_size: 7
          send_every: 1
          send_first_at: 1
    accuracy_decimals: 3


  # Gallons remaining (linear tank). If your tank isn�t linear, see Section C.2 below.
  - platform: template
    id: tank_gallons
    name: "Water Remaining"
    unit_of_measurement: "gal"
    accuracy_decimals: 1
    update_interval: 1s
    lambda: |-
      const float cap = id(tank_capacity_gal).state;
      const float pct = id(tank_percent).state;
      if (isnan(cap) || isnan(pct)) return NAN;
      return cap * (pct / 100.0f);
    on_value:
      then:
        - script.execute:
            id: ui_update_from_percent
            pct: !lambda "return (int) id(tank_percent).state;"

font:
  - file: "gfonts://Montserrat"
    id: f_text_28
    size: 28
    bpp: 4
  - file: "gfonts://Montserrat"
    id: f_value_64
    size: 64
    bpp: 4

# https://docs.lvgl.io/master/details/widgets/base_widget.html
lvgl:
  displays:
    - display_id: display
  touchscreens:
    - touchscreen_id: touchscreen

  on_ready:
    then:
      - lvgl.screen.create:
          id: scr_main
          bg_color: 0x000000

      - lvgl.widget.create:
          type: tabview
          id: tv
          parent: scr_main
          width: 466
          height: 466
          x: 0
          y: 0
          tabbar_hidden: true
          swipe: true

      - lvgl.tab.create:
          tabview_id: tv
          id: tab_water_level
          title: "Water Level"

      - lvgl.tab.create:
          tabview_id: tv
          id: tab_other
          title: ""

      - lvgl.widget.create:
          type: arc
          id: gauge_arc
          parent: tab_gauge
          x: 23
          y: 23
          width: 420
          height: 420
          arc_width: 26
          arc_color: 0x00D1B2 # Caribbean Green
          range_from: 0
          range_to: 100
          value: 0
          bg_angles: { start: 135, end: 405 } # 270� arc

      - lvgl.widget.create:
          type: label
          id: gauge_value
          parent: tab_gauge
          text: "0%"
          align: CENTER
          text_color: 0xFFFFFF
          text_font: f_value_64
          
      - lvgl.widget.create:
          type: label
          id: other_title
          parent: tab_other
          text: "Other Mode"
          align: TOP_MID
          x: 0
          y: 20
          text_color: 0xFFFFFF
          text_font: f_text_36

          
      - lvgl.widget.create:
          type: obj
          id: tap_layer
          parent: scr_main
          width: 466
          height: 466
          x: 0
          y: 0
          bg_opa: TRANSP
          clickable: true


      - lvgl.event:
          target: tap_layer
          type: clicked
          then:
            - lambda: |-
                uint16_t idx = lv_tabview_get_tab_act(id(tv));
                lv_tabview_set_act(id(tv), (idx == 0) ? 1 : 0, LV_ANIM_ON);

      - lvgl.screen.load: scr_main



script:
  - id: update_gauge
    mode: restart
    parameters:
      pct: int
    then:
      - lambda: |-
          // Grab screen children: we�ll search by type; or cache pointers in statics.
          // (We cached arc/label in the on_ready block as statics; retrieve them here.)
          extern "C" {
            // Access the statics by re-declaring them (file-scope in generated C++).
            // The compiler will merge them if names match; ESPHome inlines per component.
          }
          // As a practical approach in ESPHome, re-find by order:
          //   The 2nd arc is our value arc; the centered big label is our value text.
          // For robustness, we�ll remember across calls with static pointers:
          static lv_obj_t* arc_val = nullptr;
          static lv_obj_t* lbl_val = nullptr;

          if (!arc_val || !lbl_val) {
            // Find by scanning screen children once
            lv_obj_t* scr = lv_scr_act();
            lv_obj_t* child = lv_obj_get_child(scr, 0);
            while (child) {
              if (lv_obj_check_type(child, &lv_arc_class)) {
                // Heuristic: the second arc we created is the value arc (thicker/rounded)
                static int arc_count = 0;
                arc_count++;
                if (arc_count == 2) arc_val = child;
              } else if (lv_obj_check_type(child, &lv_label_class)) {
                // The big label (value) has our big font; we can just take first centered label.
                // Simpler: first label we created after arcs.
                if (!lbl_val) lbl_val = child;
              }
              child = lv_obj_get_child(scr, 0); // NOTE: LVGL v9 uses different iterator; ESPHome wraps; this is illustrative
              // In ESPHome it�s often easier to create via `lvgl.widget.create` and refer by IDs.
            }
          }

          int val = pct;
          if (val < 0) val = 0;
          if (val > 100) val = 100;

          // Animate arc value
          if (arc_val) {
            lv_anim_t a;
            lv_anim_init(&a);
            lv_anim_set_var(&a, arc_val);
            lv_anim_set_values(&a, lv_arc_get_value(arc_val), val);
            lv_anim_set_time(&a, 300);
            lv_anim_set_exec_cb(&a, [](void* obj, int32_t v){
              lv_arc_set_value((lv_obj_t*)obj, v);
            });
            lv_anim_start(&a);
          }

          // Update label text
          if (lbl_val) {
            char buf[8];
            snprintf(buf, sizeof(buf), "%d%%", val);
            lv_label_set_text(lbl_val, buf);
          }