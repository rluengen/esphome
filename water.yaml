# The water tank display shows the current level of the water tank as a percentage
# and the number of gallons remaining. It also allows control over the water pump
# (which automatically turns off after a timeout), the pump supply, and the
# water fill valve.

# https://esphome.io/components/sensor/adc/#esp32-pins-and-hardware-details
# there is a 12 pin multi-functional pin header on the waveshare board. This is an ESP32-S3
# So ADC1 pins are GPIO1-GPIO10, ADC2 pins are GPIO11-GPIO20. So, on the waveshare board
# we don't have access to any of these items, so i2c seems like the best option.

# The 10 pin header on the board includes:
#   GPIO0
#   GND
#   RXD (GPIO44)
#   TXD (GPIO43)
# - SDA (GPIO15)
# - SCL (GPIO07)
# - 3V3
# - GND
#   D+ (GPIO20)
#   D- (GPIO19)
#   VBUS (+5V)
#   GND

# TODO: ADS1115 via I2C to read water tank level sensor, connected from a stemma QT port to the ADS1115 to the i2c relay.
# https://www.adafruit.com/product/1085
# https://www.adafruit.com/product/4424
# Then I just need the voltage divider circuit from the water tank sensor to the ADS1115 input.

# xl9535 Device
# Relay 1: relay_hydrant_valve
# Relay 2: relay_supply_valve
# Relay 3: relay_fill_valve
# Relay 4: relay_water_pump

# and now I have the hot water heater on a 30 amp relay, the water pump switch on an input, and an LED on the 
# switch to show if the water pump is currently on. I can hook the 12V LED straight to the water pump power.
# The 30 amp relay for hot water and the switch I can connect with the PCF8574 I2C expander if needed, or possibly
# use GPIO 43/44?
# https://www.adafruit.com/product/5545


# F1502 water-alert
# F150A water-plus
# F150C water-remove
# F0F93 water-pump-off
# F058F water-pump
# 

substitutions:
  device_name: water
  friendly_name: Water Tank Display
  project_name: water-tank-display
  project_version: "1.0.0"
  log_level: DEBUG

packages:
  remote_packages:
    url: https://github.com/rluengen/esphome
    ref: main
    refresh: always
    files:
      - path: packages/common.yaml
        vars:
          api_encryption_key: !secret encryption_key
      - path: packages/network/wifi.yaml
        vars:
          wifi_ssid: !secret wifi_ssid
          wifi_password: !secret wifi_password
      - path: packages/time/homeassistant.yaml
      - path: packages/icons/homeassistant_icons.yaml
      - path: devices/waveshare-ESP32-S3-Touch-LCD-2.8C.yaml
        vars:
          touchscreen_id: touch_id
          display_id: round_display_id
          display_backlight_id: display_backlight_id
      - path: packages/display/sleep.yaml
        vars:
          touchscreen_id: touch_id
          backlight_id: display_backlight_id
      - path: packages/ota/http_update.yaml

esphome:
  name: ${device_name}
  friendly_name: ${friendly_name}
  project:
    name: smartvan.${project_name}
    version: ${project_version}
  on_boot:
    # ensure that all the valves are closed on first start (should be the default)
    - valve.close: valve_input_output_hydrant
    - valve.close: valve_water_pump_supply
    - valve.close: valve_fill
    - switch.turn_off: water_pump_switch

globals:
  - id: fill_start_time
    type: uint32_t
    restore_value: false

  - id: fill_start_level
    type: float
    restore_value: false

  - id: fill_rate_gpm
    type: float
    restore_value: false
    initial_value: '0.0'

  - id: tank_capacity_in_gallons
    type: float
    restore_value: false
    initial_value: '16.0'  # 16 gallon tank

  - id: pump_timer_remaining
    type: int
    restore_value: false
    initial_value: '0'

  - id: hot_water_heater_timer_remaining
    type: int
    restore_value: false
    initial_value: '0'

number:
  - platform: template
    id: tank_capacity_setting
    name: "Tank Capacity (gallons)"
    min_value: 1
    max_value: 100
    step: 0.5
    initial_value: 16.0
    optimistic: true
    entity_category: config
    mode: box
    set_action:
      - globals.set:
          id: tank_capacity_in_gallons
          value: !lambda 'return x;'

  - platform: template
    id: pump_timer_duration
    name: "Pump Timer Duration (minutes)"
    min_value: 1
    max_value: 120
    step: 1
    initial_value: 30
    entity_category: config
    optimistic: true
    mode: box
    unit_of_measurement: "minutes"

  - platform: template
    id: hot_water_heater_timer_duration
    name: "Hot Water Heater Timer Duration (minutes)"
    min_value: 1
    max_value: 120
    step: 1
    initial_value: 30
    entity_category: config
    optimistic: true
    mode: box
    unit_of_measurement: "minutes"

  - platform: template
    id: valve_actuation_time
    name: "Valve Actuation Time"
    min_value: 1
    max_value: 10
    step: 0.5
    initial_value: 4.0
    entity_category: config
    optimistic: true
    mode: box
    unit_of_measurement: "s"
    icon: "mdi:timer-cog"

  - platform: template
    id: full_empty_threshold_value
    name: "Tank Threshold"
    min_value: 1
    max_value: 15
    step: 0.5
    initial_value: 5.0
    entity_category: config
    optimistic: true
    mode: box
    unit_of_measurement: "%"
    icon: "mdi:percent"

  - platform: template
    id: tank_empty_resistance
    name: "Tank Empty Resistance"
    min_value: 0
    max_value: 500
    step: 1
    initial_value: 240.0
    entity_category: config
    optimistic: true
    mode: box
    unit_of_measurement: "Ohms"
    icon: "mdi:omega"

  - platform: template
    id: tank_full_resistance
    name: "Tank Full Resistance"
    min_value: 0
    max_value: 500
    step: 1
    initial_value: 33.0
    entity_category: config
    optimistic: true
    mode: box
    unit_of_measurement: "Ohms"
    icon: "mdi:omega"

# https://esphome.io/components/xl9535/
xl9535:
  - id: xl9535_hub
    i2c_id: i2c_bus
    address: 0x20  # Common address for XL9535, may be 0x20, 0x21, 0x24, or 0x27

pcf8574:
  - id: pcf8574_hub
    i2c_id: i2c_bus
    address: 0x21       # The I2C address of the driver. 0x20 is the default, bridge A0 to get 0x21 not to conflict with the board.
    pcf8575: false      # Whether this is a 16-pin PCF8575

binary_sensor:
  - platform: template
    id: water_tank_full
    name: "Water Tank Full"
    entity_category: diagnostic
    lambda: |-
      if (isnan(id(tank_percent).state)) return false;
      return id(tank_percent).state >= (100.0f - (float)id(full_empty_threshold_value).state);
    on_press:
      then:
        - logger.log: "Tank full - stopping fill operations"
        - script.stop: water_fill
        - valve.close: valve_fill
        - valve.close: valve_input_output_hydrant

  - platform: template
    id: water_tank_low
    name: "Water Tank Low"
    entity_category: diagnostic
    lambda: |-
      if (isnan(id(tank_percent).state)) return true;
      return id(tank_percent).state <= (float)id(full_empty_threshold_value).state;
    on_press:
      then:
        - if:
            condition:
              and:
                - switch.is_on: water_pump_switch
                - lambda: 'return id(valve_water_pump_supply).current_operation == VALVE_OPERATION_OPENING || id(valve_water_pump_supply).position == VALVE_OPEN;'
            then:
              - logger.log: "Dry-run protection: Tank too low, stopping pump"
              - switch.turn_off: water_pump_switch
              - script.stop: pump_timer_countdown

  - platform: homeassistant
    id: water_leak_detected
    entity_id: binary_sensor.water_leak
    on_press:
      then:
        - logger.log: "Water leak detected - emergency shutdown"
        - switch.turn_off: water_pump_switch
        - valve.close: valve_water_pump_supply
        - valve.close: valve_input_output_hydrant
        - valve.close: valve_fill
        - script.stop: pump_timer_countdown
        - script.stop: water_fill
        - lvgl.label.update:
            id: lbl_tank_status
            text: "Water Leak"

  - platform: gpio
    name: "Water Pump Remote Switch"
    id: water_pump_button
    pin:
      pcf8574: pcf8574_hub
      number: 0
      mode:
        input: true
      inverted: true
    filters:
      - delayed_on: 10ms
      - delayed_off: 10ms
    on_press:
      then:
        - logger.log: "Water pump button pressed"
        - switch.toggle: water_pump_switch

ads1115:
  - id: ads_device_id
    address: 0x48 # Address pin is pulled to GND (Default)

sensor:
  # How to choose gain:
  #   Measure your voltage divider output range:
  #   With tank empty (240 ohm sender): What voltage do you get?
  #   With tank full (33 ohm sender): What voltage do you get?
  # For a typical voltage divider with 220 ohm reference resistor and 3.3V supply:
  #   Empty (240 ohm): ~3.3V × 240/(240+220) = 1.72V
  #   Full (33 ohm): ~3.3V × 33/(33+220) = 0.43V
  # Range: 0.4V to 1.7V
  # Pick the smallest gain that fits your range:
  # Your range is 0-1.7V → Use gain: 2.048 (gives you headroom + best resolution)
  - platform: ads1115
    id: water_tank_adc_v
    ads1115_id: ads_device_id
    multiplexer: 'A0_GND'
    gain: 2.048  # ±2.048V range - 0.0625 mV per bit
    name: "ADS1115 Channel A0-GND"

  # It's a software helper in ESPHome that calculates resistance (in ohms) from an ADC voltage 
  # reading using a known reference resistor in a voltage divider.
  # https://esphome.io/components/sensor/resistance/
  # +3.3v --- [5.6k Resistor] -- A0_GND -- [Tank Resistor] -- GND
  - platform: resistance
    id: sender_ohms
    name: "Fresh Water Sender Resistance (ohms)"
    sensor: water_tank_adc_v  # This is your ADC voltage sensor
    configuration: DOWNSTREAM # Position of unknown resistor in divider
    resistor: 5.6kOhm # (Required, float): The value of the resistor with a constant value.
    reference_voltage: 3.3 V # (Optional, float): The reference voltage. Defaults to 3.3V.
    state_class: measurement

    filters:
      - median:
          window_size: 15
          send_every: 5
      - exponential_moving_average:
          alpha: 0.1
      - clamp:
          min_value: 33.0
          max_value: 240.0

  - platform: template
    id: tank_percent
    name: "Fresh Water Tank Level (%)"
    unit_of_measurement: "%"
    accuracy_decimals: 0
    state_class: measurement
    
    # Calibrate non-linear tank by mapping resistance (ohms) to percentage
    # Measure resistance at different fill levels and add points here
    filters:
      - calibrate_linear:
          # Format: resistance -> percentage
          # Measure at empty, 1/4, 1/2, 3/4, full and add points
          - 240.0 -> 0.0    # Empty
          - 160.0 -> 25.0   # 1/4 full (example - measure actual)
          - 100.0 -> 50.0   # 1/2 full (example - measure actual)
          - 60.0 -> 75.0    # 3/4 full (example - measure actual)
          - 33.0 -> 100.0   # Full
      - clamp:
          min_value: 0.0
          max_value: 100.0

    lambda: |-
      // Return raw ohms reading for calibration filter
      if (isnan(id(sender_ohms).state)) return NAN;
      return id(sender_ohms).state;

    on_value:
      then:
        - lambda: |-
            float gallons = NAN;
            if (!isnan(id(tank_percent).state))
            {
              gallons = id(tank_capacity_in_gallons) * (id(tank_percent).state / 100.0f);
            }
            id(tank_gallons).publish_state(gallons);

        - lvgl.arc.update:
            id: tank_arc
            value: !lambda |-
              if (isnan(x))
              {
                return 0.0;
              }
              return x;

        - lvgl.label.update:
            id: lbl_tank_percent
            text: !lambda |-
              static char buf[16];
              if (isnan(x))
              {
                snprintf(buf, sizeof(buf), "-.- %%");
              }
              else
              {
                snprintf(buf, sizeof(buf), "%.0f %%", x);
              }
              return buf;

        - lvgl.label.update:
            id: lbl_tank_status
            text: !lambda |-
              // Check for water leak first - highest priority
              if (id(water_leak_detected).state) return "Water Leak";
              
              if (isnan(x)) return "Unknown";
              else if (x >= 95.0) return "Full";
              else if (x >= 75.0) return "High";
              else if (x >= 50.0) return "Medium";
              else if (x >= 25.0) return "Low";
              else if (x >= 10.0) return "Very Low";
              else return "Empty";

        - lvgl.arc.update:
            id: tank_arc
            arc_color: !lambda |-
              if (isnan(x)) return lv_color_hex(0x7F7F7F);            // Gray - Unknown
              else if (x >= 95.0) return lv_color_hex(0x00FF00);      // Green - Full
              else if (x >= 75.0) return lv_color_hex(0x00FF00);      // Green - High
              else if (x >= 50.0) return lv_color_hex(0x0080FF);      // Blue - Medium
              else if (x >= 25.0) return lv_color_hex(0xFFAA00);      // Orange - Low
              else return lv_color_hex(0xFF0000);                     // Red - Very Low

  - platform: template
    id: tank_gallons
    name: "Tank Gallons Remaining"
    unit_of_measurement: "gal"
    accuracy_decimals: 1
    state_class: measurement
    on_value:
      then:
        - lvgl.label.update:
            id: lbl_tank_gallons
            text: !lambda |-
              static char buf[16];
              if (isnan(id(tank_percent).state))
              {
                snprintf(buf, sizeof(buf), "-.- gal", x);
              }
              else
              {
                snprintf(buf, sizeof(buf), "%.1f gal", x);
              }
              return buf;

  - platform: template
    id: estimated_time_to_fill
    name: "Estimated Time to Fill"
    unit_of_measurement: "min"
    accuracy_decimals: 1
    state_class: measurement
    lambda: |-
      if (id(fill_rate_gpm) <= 0.0 || isnan(id(tank_percent).state)) return NAN;
      
      float remaining_gallons = id(tank_capacity_in_gallons) * (100.0 - id(tank_percent).state) / 100.0;
      float minutes = remaining_gallons / id(fill_rate_gpm);
      return minutes;

# https://pictogrammers.com/library/mdi/

# https://esphome.io/components/valve/template/
# Requires Home Assistant 2024.5 or later to use valves.
valve:
  # The valve which controls the external hydrant being used.
  # Closed (default) = Hydrant Out
  # Open = Hydrant in (Fresh Fill)
  - platform: template
    device_class: water
    id: valve_input_output_hydrant
    name: "Input Hydrant Selection Valve"
    icon: "mdi:valve"
    lambda: |-
      return {};
    open_action:
      - script.execute: screen_bump_activity
      - if:
          condition:
            binary_sensor.is_on: water_tank_full
          then:
            - logger.log: "Cannot open hydrant valve - tank is full"
          else:
            - logger.log: "Input Selection Valve Opening"
            - switch.turn_on: relay_hydrant_valve
            - valve.template.publish:
                id: valve_input_output_hydrant
                current_operation: OPENING
            - delay: !lambda 'return (uint32_t)(id(valve_actuation_time).state * 1000);'
            - valve.template.publish:
                id: valve_input_output_hydrant
                current_operation: IDLE
                position: !lambda "return VALVE_OPEN;"
            - lvgl.label.update:
                id: lbl_valve_hydrant
                text: "\U000F1068"
            - logger.log: "Input Selection Valve Opened"
    close_action:
      - script.execute: screen_bump_activity
      - logger.log: "Input Selection Valve Closing"
      - switch.turn_off: relay_hydrant_valve
      - valve.template.publish:
          id: valve_input_output_hydrant
          current_operation: CLOSING
      - delay: !lambda 'return (uint32_t)(id(valve_actuation_time).state * 1000);'
      - valve.template.publish:
          id: valve_input_output_hydrant
          current_operation: IDLE
          position: !lambda "return VALVE_CLOSED;"
      - lvgl.label.update:
          id: lbl_valve_hydrant
          text: "\U000F1067"
      - logger.log: "Input Selection Valve Closed"
    assumed_state: false
    optimistic: false
    has_position: true

  # The valve which controls the input to the water pump. This is either
  # the water tank or the external (dirty) fill port.
  # Closed (default) = Dirty Water Fill Port
  # Open = Water Tank
  - platform: template
    device_class: water
    id: valve_water_pump_supply
    name: "Water Pump Supply Selector Valve"
    icon: "mdi:valve"
    lambda: |-
      return {};
    open_action:
      - script.execute: screen_bump_activity
      - if:
          condition:
            binary_sensor.is_on: water_tank_low
          then:
            - logger.log: "Cannot open water pump Supply Valve - tank is too low"
          else:
            - logger.log: "Water Pump Supply Valve Opening"
            - switch.turn_on: relay_supply_valve
            - valve.template.publish:
                id: valve_water_pump_supply
                current_operation: OPENING
            - valve.close: valve_fill
            - delay: !lambda 'return (uint32_t)(id(valve_actuation_time).state * 1000);'
            - valve.template.publish:
                id: valve_water_pump_supply
                current_operation: IDLE
                position: !lambda "return VALVE_OPEN;"
            - lvgl.label.update:
                id: lbl_valve_supply
                text: "\U000F1068"
            - logger.log: "Water Pump Supply Valve Opened"
    close_action:
      - script.execute: screen_bump_activity
      - logger.log: "Water Pump Supply Valve Closing"
      - switch.turn_off: relay_supply_valve
      - valve.template.publish:
          id: valve_water_pump_supply
          current_operation: CLOSING
      - delay: !lambda 'return (uint32_t)(id(valve_actuation_time).state * 1000);'
      - valve.template.publish:
          id: valve_water_pump_supply
          current_operation: IDLE
          position: !lambda "return VALVE_CLOSED;"
      - lvgl.label.update:
          id: lbl_valve_supply
          text: "\U000F1067"
      - logger.log: "Water Pump Supply Valve Closed"
    assumed_state: false
    optimistic: false
    has_position: true

  # The water fill valve controls if water is pumped into the water tank.
  # This should not be an option if the water source is the water tank.
  # Closed (default) = no fill
  # Open = Fill Water Tank from Water Pump
  - platform: template
    device_class: water
    id: valve_fill
    name: "Tank Fill Valve"
    icon: "mdi:valve"
    lambda: |-
      return {};
    open_action:
      - script.execute: screen_bump_activity
      - if:
          condition:
            binary_sensor.is_on: water_tank_full
          then:
            - logger.log: "Cannot open fill valve - tank is full"
          else:
            - logger.log: "Tank Fill Valve Opening"
            - switch.turn_on: relay_fill_valve
            - valve.template.publish:
                id: valve_fill
                current_operation: OPENING
            - delay: !lambda 'return (uint32_t)(id(valve_actuation_time).state * 1000);'
            - valve.template.publish:
                id: valve_fill
                current_operation: IDLE
                position: !lambda "return VALVE_OPEN;"
            - lvgl.label.update:
                id: lbl_valve_fill
                text: "\U000F1068"
            - logger.log: "Tank Fill Valve Opened"
    close_action:
      - script.execute: screen_bump_activity
      - logger.log: "Tank Fill Valve Closing"
      - switch.turn_off: relay_fill_valve
      - valve.template.publish:
          id: valve_fill
          current_operation: CLOSING
      - delay: !lambda 'return (uint32_t)(id(valve_actuation_time).state * 1000);'
      - valve.template.publish:
          id: valve_fill
          current_operation: IDLE
          position: !lambda "return VALVE_CLOSED;"
      - lvgl.label.update:
          id: lbl_valve_fill
          text: "\U000F1067"
      - logger.log: "Tank Fill Valve Closed"
    assumed_state: false
    optimistic: false
    has_position: true

switch:
  - platform: template
    id: water_pump_switch
    name: "Water Pump"
    lambda: |-
      return id(relay_water_pump).state;
    turn_on_action:
      - script.execute: screen_bump_activity
      - if:
          condition:
            and:
              - binary_sensor.is_on: water_tank_low
              - lambda: 'return id(valve_water_pump_supply).current_operation == VALVE_OPERATION_OPENING || id(valve_water_pump_supply).position == VALVE_OPEN;'
          then:
            - logger.log: "Dry-run protection: Cannot start pump - tank too low"
          else:
            - valve.open: valve_water_pump_supply
            - wait_until:
                condition:
                  lambda: 'return id(valve_water_pump_supply).position == VALVE_OPEN;'
                timeout: 15s
            - if:
                condition:
                  lambda: 'return id(valve_water_pump_supply).position == VALVE_OPEN;'
                then:
                  - switch.turn_on: relay_water_pump
                  - lvgl.label.update:
                      id: lbl_pump_status
                      text: "\U000F058E"  # water-pump icon (on)
                      text_color: 0x00BFFF  # Deep sky blue for running
                else:
                  - logger.log: "ERROR: Valve failed to open - pump not started"
    turn_off_action:
      - script.execute: screen_bump_activity
      - switch.turn_off: relay_water_pump
      - delay: 250ms  # Wait for pump to stop before closing valves
      - valve.close: valve_water_pump_supply
      - valve.close: valve_input_output_hydrant
      - lvgl.label.update:
          id: lbl_pump_status
          text: "\U000F0F93"  # water-pump-off icon
          text_color: 0x888888  # Gray for off

  - platform: template
    id: hot_water_heater_switch
    name: "Hot Water Heater"
    icon: "mdi:water-boiler"
    lambda: |-
      return id(hot_water_heater_relay).state;
    turn_on_action:
      - switch.turn_on: hot_water_heater_relay
      - lvgl.label.update:
          id: lbl_hot_water_status
          text: "\U000F0F92"  # water-boiler icon (on)
          text_color: 0xFF6600  # Orange for heating
      - script.execute: hot_water_heater_timer_countdown
    turn_off_action:
      - switch.turn_off: hot_water_heater_relay
      - lvgl.label.update:
          id: lbl_hot_water_status
          text: "\U000F0F91"  # water-boiler-off icon
          text_color: 0x888888  # Gray for off
      - script.stop: hot_water_heater_timer_countdown

  # XL9535 relay outputs
  - platform: gpio
    id: relay_hydrant_valve
    name: "Hydrant Valve Relay"
    internal: true
    pin:
      xl9535: xl9535_hub
      number: 0
      mode: OUTPUT
      inverted: false

  - platform: gpio
    id: relay_supply_valve
    name: "Supply Valve Relay"
    internal: true
    pin:
      xl9535: xl9535_hub
      number: 1
      mode: OUTPUT
      inverted: false

  - platform: gpio
    id: relay_fill_valve
    name: "Fill Valve Relay"
    internal: true
    pin:
      xl9535: xl9535_hub
      number: 2
      mode: OUTPUT
      inverted: false

  - platform: gpio
    id: relay_water_pump
    name: "Water Pump Relay"
    internal: true
    pin:
      xl9535: xl9535_hub
      number: 3
      mode: OUTPUT
      inverted: false
    interlock_wait_time: 100ms
    on_turn_on:
      - if:
          condition:
            and:
              - binary_sensor.is_on: water_tank_low
              - lambda: 'return id(valve_water_pump_supply).current_operation == VALVE_OPERATION_OPENING || id(valve_water_pump_supply).position == VALVE_OPEN;'
          then:
            - logger.log: "Dry-run protection: Cannot turn on pump - tank low and supply is tank"
            - switch.turn_off: relay_water_pump

  # PCF8574 outputs
  - platform: gpio
    id: hot_water_heater_relay
    name: "Hot Water Heater Relay"
    internal: true
    pin:
      pcf8574: pcf8574_hub
      number: 1
      mode: OUTPUT
      inverted: false

font:
  - file: "fonts/segoeui.ttf"
    id: f_text_32
    size: 32
    bpp: 4

  - file: "fonts/segoeui.ttf"
    id: f_value_90
    size: 60
    bpp: 4

  - file: "fonts/segoeui.ttf"
    id: f_text_24
    size: 24
    bpp: 4

  - file: "fonts/materialdesignicons-webfont.ttf"
    id: valve_icon_40
    size: 30
    bpp: 4
    glyphs: [
      "\U000F1066", # valve
      "\U000F1067", # valve-closed
      "\U000F1068", # valve-open
      "\U000F058E", # water-pump
      "\U000F0F93", # water-pump-off  
      "\U000F0F92", # water-boiler
      "\U000F0F91", # water-boiler-off
    ]

color:
  - id: background
    hex: '000000'
  - id: text_foreground
    hex: 'FFFFFF'

api:
  on_client_connected:
    - if:
        condition:
          lambda: 'return (0 == client_info.find("Home Assistant "));'
        then:
          - lvgl.widget.show: lbl_connection_status
  on_client_disconnected:
    - if:
        condition:
          lambda: 'return (0 == client_info.find("Home Assistant "));'
        then:
          - lvgl.widget.hide: lbl_connection_status

# https://docs.lvgl.io/master/details/widgets/base_widget.html
lvgl:
  bg_color: 0x000000
  buffer_size: 100%
  bg_opa: COVER

  on_boot:
    then:
      - logger.log: "LVGL boot"
      - lambda: |-
          lv_obj_t* arc = id(tank_arc);
          lv_obj_set_style_arc_width(arc, 25, LV_PART_INDICATOR);   // foreground
          lv_obj_set_style_arc_width(arc, 25, LV_PART_MAIN);        // background
          lv_obj_set_style_arc_color(arc, lv_color_hex(0xFFAA00), LV_PART_MAIN); // background

  touchscreens:
    - touchscreen_id: touch_id
      long_press_time: 400ms
      long_press_repeat_time: 100ms

  widgets:
    - obj:
        align: CENTER
        height: 100%
        width: 100%
        bg_color: 0x000000
        scrollbar_mode: "OFF"
        scrollable: false
        on_click:
          then:
            - logger.log: "Pump UI on_click"
            - switch.toggle: water_pump_switch

        widgets:
        # Water Fill toggle button
        - button:
            id: btn_water_fill
            align: TOP_MID
            y: 30
            width: 80
            height: 60
            checkable: true
            bg_color: 0x333333
            on_click:
              then:
                - if:
                    condition:
                      lambda: 'return lv_obj_has_state(id(btn_water_fill), LV_STATE_CHECKED);'
                    then:
                      # Turning ON
                      - logger.log: "Water Fill button ON"
                      - valve.close: valve_input_output_hydrant
                      - script.execute: water_fill
                    else:
                      # Turning OFF
                      - logger.log: "Water Fill button OFF"
                      - script.stop: water_fill
                      - switch.turn_off: relay_water_pump
                      - valve.close: valve_fill
                      - lvgl.label.update:
                          id: lbl_pump_status
                          text: "\U000F0F93"
                          text_color: 0x888888
            widgets:
              - label:
                  id: lbl_water_fill_btn
                  align: CENTER
                  text: "Fill"
                  text_color: 0xFFFFFF
                  text_font: f_text_24

        # Center gallons display
        - label:
            id: lbl_tank_gallons
            text: "-.- gal"
            align: CENTER
            y: -15
            text_font: f_value_90
            text_color: 0xFFFFFF
            text_align: CENTER
            clickable: false

        # Percentage display below
        - label:
            id: lbl_tank_percent
            text: "- %"
            align: CENTER
            y: 80
            text_font: f_text_32
            text_color: 0xAAAAAA
            text_align: CENTER
            clickable: false

        # Timer countdown display - visible when pump is running
        - label:
            id: lbl_timer
            text: ""
            align: TOP_MID
            y: 50
            text_font: f_text_24
            text_color: 0xFFAA00
            text_align: CENTER
            clickable: false
            hidden: true  # Hide by default, show only during countdown

        # Tank level arc (rendered on top, non-clickable)
        - arc:
            id: tank_arc
            height: 460
            width: 460
            align: CENTER
            arc_width: 25
            arc_color: 0x0080FF
            arc_rounded: true
            value: 0
            min_value: 0
            max_value: 100
            start_angle: 135
            x: 3
            end_angle: 45  # 270 degree arc
            bg_opa: TRANSP
            adjustable: false
            arc_opa: COVER
            clickable: false

        # Tank status label at bottom
        - label:
            id: lbl_tank_status
            text: ""
            align: BOTTOM_MID
            y: -15
            text_font: f_text_32
            text_color: 0x888888
            text_align: CENTER
            clickable: false

        # Status icons row above tank status
        - label:
            id: lbl_connection_status
            align: BOTTOM_LEFT
            x: 20
            y: -60
            text_align: LEFT
            text_font: homeassistant_icons
            text: "\U000F07D0"
            text_color: 0x03A9F4 # Blue color for Home Assistant icon
            clickable: false

        - label:
            id: lbl_valve_hydrant
            text: "\U000F1066"
            align: BOTTOM_LEFT
            x: 130
            y: -60
            text_font: valve_icon_40
            text_color: 0x00CED1  # Turquoise for hydrant
            text_align: LEFT
            clickable: false

        - label:
            id: lbl_valve_supply
            text: "\U000F1066"
            align: BOTTOM_LEFT
            x: 190
            y: -60
            text_font: valve_icon_40
            text_color: 0x888888  # Gray for supply
            text_align: LEFT
            clickable: false

        - label:
            id: lbl_valve_fill
            text: "\U000F1066"
            align: BOTTOM_LEFT
            x: 250
            y: -60
            text_font: valve_icon_40
            text_color: 0x00FF00  # Green for fill
            text_align: LEFT
            clickable: false

        # Water pump indicator
        - label:
            id: lbl_pump_status
            text: "\U000F0F93"  # water-pump-off icon
            align: BOTTOM_LEFT
            x: 310
            y: -60
            text_font: valve_icon_40
            text_color: 0x888888  # Gray for off
            text_align: LEFT
            clickable: false

        # Hot water heater indicator  
        - label:
            id: lbl_hot_water_status
            text: "\U000F0F91"  # water-boiler-off icon
            align: BOTTOM_LEFT
            x: 370
            y: -60
            text_font: valve_icon_40
            text_color: 0x888888  # Gray for off
            text_align: LEFT
            clickable: false
            
script:
  - id: water_fill
    then:
      - if:
          condition:
            binary_sensor.is_off: water_tank_full
          then:
            # Record start conditions
            - lambda: |-
                id(fill_start_time) = millis();
                id(fill_start_level) = id(tank_percent).state;

            - logger.log: "Water Fill: Configuring valves"
            - valve.close: valve_water_pump_supply
            - valve.open: valve_fill
            - valve.close: valve_input_output_hydrant
            
            # Wait for valves to reach their positions
            - logger.log: "Water Fill: Waiting for valves"
            - wait_until:
                condition:
                  and:
                    - lambda: 'return id(valve_water_pump_supply).position == VALVE_CLOSED;'
                    - lambda: 'return id(valve_fill).position == VALVE_OPEN;'
                timeout: 20s
            
            # Turn on pump
            - logger.log: "Water Fill: Starting pump"
            - switch.turn_on: relay_water_pump
            - lvgl.label.update:
                id: lbl_pump_status
                text: "\U000F058E"  # water-pump icon (on)
                text_color: 0x00BFFF  # Deep sky blue for running
            
            # Monitor fill progress
            - repeat:
                count: 1800 # 30 minutes * 60 seconds
                then:
                  - delay: 1s

                  # Check if tank is full and auto-stop
                  - if:
                      condition:
                        binary_sensor.is_on: water_tank_full
                      then:
                        - logger.log: "Water Fill: Tank full - auto-stopping"
                        - switch.turn_off: relay_water_pump
                        - valve.close: valve_fill
                        - lvgl.label.update:
                            id: lbl_pump_status
                            text: "\U000F0F93"
                            text_color: 0x888888
                        - lvgl.button.update:
                            id: btn_water_fill
                            state:
                              checked: false
                        - script.stop: water_fill

                  # Check if level is increasing after 30 seconds
                  - lambda: |-
                      uint32_t elapsed_ms = millis() - id(fill_start_time);
                      float elapsed_min = elapsed_ms / 60000.0;
                      
                      if (elapsed_min > 0.5) {  // After 30 seconds
                        float level_change = id(tank_percent).state - id(fill_start_level);
                        
                        // If level hasn't increased by at least 0.5% in 30 seconds, stop
                        if (level_change < 0.5) {
                          ESP_LOGW("water_fill", "Tank level not increasing - stopping pump");
                          id(water_pump_switch).turn_off();
                          id(water_fill).stop();
                        }
                      }

  - id: pump_timer_countdown
    mode: restart
    then:
      - lvgl.widget.show: lbl_timer  # Show the timer label
      - lambda: 'id(pump_timer_remaining) = (int)id(pump_timer_duration).state * 60;'
      - while:
          condition:
            lambda: 'return id(pump_timer_remaining) > 0 && id(water_pump_switch).state;'
          then:
            - lambda: |-
                int remaining = id(pump_timer_remaining);
                int mins = remaining / 60;
                int secs = remaining % 60;
                char buf[32];
                snprintf(buf, sizeof(buf), "%d:%02d", mins, secs);
                lv_label_set_text(id(lbl_timer), buf);
                id(pump_timer_remaining)--;
            - delay: 1s
      - if:
          condition:
            lambda: 'return id(pump_timer_remaining) <= 0;'
          then:
            - logger.log: "Pump timer expired - turning off pump"
            - switch.turn_off: water_pump_switch
          else:
            - logger.log: "Pump turned off - stopping countdown"
      - lvgl.label.update:
          id: lbl_timer
          text: ""
      - lvgl.widget.hide: lbl_timer  # Hide the timer label

  - id: hot_water_heater_timer_countdown
    mode: restart
    then:
      - lambda: 'id(hot_water_heater_timer_remaining) = (int)id(hot_water_heater_timer_duration).state * 60;'
      - while:
          condition:
            lambda: 'return id(hot_water_heater_timer_remaining) > 0 && id(hot_water_heater_switch).state;'
          then:
            - lambda: |-
                id(hot_water_heater_timer_remaining)--;
            - delay: 1s
      - if:
          condition:
            lambda: 'return id(hot_water_heater_timer_remaining) <= 0;'
          then:
            - logger.log: "Hot water heater timer expired - turning off heater"
            - switch.turn_off: hot_water_heater_switch
          else:
            - logger.log: "Hot water heater turned off - stopping countdown"
