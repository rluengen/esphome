substitutions:
  device_name: gps
  friendly_name: Global Positioning System
  project_name: gps-receiver
  project_version: "1.0.0"
  log_level: DEBUG

packages:
  remote_packages:
    url: https://github.com/rluengen/esphome
    ref: main
    refresh: always
    files:
      - path: packages/common.yaml
        vars:
          api_encryption_key: !secret encryption_key
      - path: packages/network/wifi.yaml
        vars:
          wifi_ssid: !secret wifi_ssid
          wifi_password: !secret wifi_password
      - path: packages/time/homeassistant.yaml
      # https://wiki.seeedstudio.com/get_start_l76k_gnss/
      - path: packages/gps-receiver.yaml
        vars:
          tx_pin: GPIO21
          rx_pin: GPIO20
      - path: devices/xiao-esp32c3.yaml
      - path: packages/ota/http_update.yaml

# GPS sensorsneed to reference the component's internal sensors
# Configurable thresholds for stationary lock (adjustable from Home Assistant)
# Values are stored internally in metric, but HA will auto-convert display based on your unit system
number:
  - platform: template
    name: "Speed Unlock Threshold"
    id: speed_unlock_threshold
    icon: mdi:speedometer
    entity_category: config
    unit_of_measurement: "km/h"
    device_class: speed
    min_value: 1.0
    max_value: 10.0
    step: 0.5
    initial_value: 3.0
    restore_value: true
    optimistic: true
    on_value:
      - lambda: 'id(speed_unlock_val) = x;'
  - platform: template
    name: "Distance Unlock Threshold"
    id: distance_unlock_threshold
    icon: mdi:map-marker-distance
    entity_category: config
    unit_of_measurement: "m"
    device_class: distance
    min_value: 5.0
    max_value: 50.0
    step: 1.0
    initial_value: 15.0
    restore_value: true
    optimistic: true
    on_value:
      - lambda: 'id(distance_unlock_val) = x;'
  - platform: template
    name: "Speed Lock Threshold"
    id: speed_lock_threshold
    icon: mdi:lock
    entity_category: config
    unit_of_measurement: "km/h"
    device_class: speed
    min_value: 0.5
    max_value: 5.0
    step: 0.5
    initial_value: 1.0
    restore_value: true
    optimistic: true
    on_value:
      - lambda: 'id(speed_lock_val) = x;'

# The gps component exposes satellites through globals, so we use a workaround
globals:
  - id: satellite_count
    type: int
    initial_value: '0'
  # Stationary lock globals
  - id: locked_lat
    type: float
    initial_value: '0.0'
  - id: locked_lon
    type: float
    initial_value: '0.0'
  - id: is_position_locked
    type: bool
    initial_value: 'false'
  - id: raw_longitude
    type: float
    initial_value: '0.0'
  # Threshold globals (updated by number entities)
  - id: speed_unlock_val
    type: float
    initial_value: '3.0'
  - id: distance_unlock_val
    type: float
    initial_value: '15.0'
  - id: speed_lock_val
    type: float
    initial_value: '1.0'

# Override the GPS component from package
gps:
  satellites:
    id: gps_satellites
    on_value:
      - lambda: 'id(satellite_count) = (int)x;'
  speed:
    id: gps_speed
    name: "Speed"
  longitude:
    id: gps_longitude
    internal: true
    on_value:
      - lambda: 'id(raw_longitude) = x;'
      - component.update: stabilized_longitude
  latitude:
    id: gps_latitude
    internal: true
    on_value:
      - component.update: stabilized_latitude

sensor:
  - platform: template
    name: "Latitude"
    id: stabilized_latitude
    accuracy_decimals: 6
    update_interval: never
    state_class: measurement
    lambda: |-
      float raw_lat = id(gps_latitude).state;
      float raw_lon = id(raw_longitude);
      float speed = id(gps_speed).state;
      int sats = id(satellite_count);
      
      // Calculate distance from locked position (in meters)
      float dist = 0;
      if (id(is_position_locked)) {
        float dlat = (raw_lat - id(locked_lat)) * 111320.0;
        float dlon = (raw_lon - id(locked_lon)) * 111320.0 * cos(raw_lat * 0.0174533);
        dist = sqrt(dlat*dlat + dlon*dlon);
      }
      
      // Unlock conditions (using globals to avoid circular dependency)
      bool should_unlock = (speed > id(speed_unlock_val)) || 
                           (id(is_position_locked) && dist > id(distance_unlock_val));
      
      // Lock conditions
      bool should_lock = (speed < id(speed_lock_val)) && (sats >= 4);
      
      if (id(is_position_locked)) {
        if (should_unlock) {
          id(is_position_locked) = false;
          ESP_LOGI("gps", "Position UNLOCKED (speed=%.1f, dist=%.1fm)", speed, dist);
        } else {
          return id(locked_lat);
        }
      } else if (should_lock) {
        id(is_position_locked) = true;
        id(locked_lat) = raw_lat;
        id(locked_lon) = raw_lon;
        ESP_LOGI("gps", "Position LOCKED at %.6f, %.6f", raw_lat, raw_lon);
      }
      return raw_lat;
  
  - platform: template
    name: "Longitude"
    id: stabilized_longitude
    accuracy_decimals: 6
    update_interval: never
    state_class: measurement
    lambda: |-
      if (id(is_position_locked)) {
        return id(locked_lon);
      }
      return id(raw_longitude);

binary_sensor:
  - platform: template
    name: "GPS Fix"
    lambda: return id(gps_satellites).state >= 4;
  - platform: template
    name: "Position Locked"
    id: position_locked_sensor
    icon: mdi:lock
    lambda: return id(is_position_locked);
  - platform: template
    name: "Movement Detected"
    id: movement_detected
    icon: mdi:motion-sensor
    lambda: return id(gps_speed).state > 2.0;  // > 2 km/h
    filters:
      - delayed_on: 3s   # Must be moving for 3s to trigger
      - delayed_off: 10s # Must be stopped for 10s to clear

text_sensor:
  - platform: template
    name: "GPS Signal Quality"
    lambda: |-
      int sats = id(satellite_count);
      if (sats >= 8) return {"Excellent"};
      if (sats >= 6) return {"Good"};
      if (sats >= 4) return {"Fair"};
      return {"Poor/No Fix"};

esphome:
  name: ${device_name}
  friendly_name: ${friendly_name}
  project:
    name: smartvan.${project_name}
    version: ${project_version}
  on_boot:
    priority: -10
    then:
      - delay: 500ms  # Let GPS stabilize
      - lambda: |-
          // First set baud rate to 115200
          id(gps_uart).write_str("$$PCAS01,7*18\r\n");
      - delay: 100ms
      - lambda: |-
          // Set the speed according to selected rate
          std::string rate = id(gps_rate_select).current_option();
          if (rate == "1Hz (Low Power)") {
            id(gps_uart).write_str("$$PCAS04,3*1A\r\n");  // GPS+GLONASS+Galileo
            id(gps_uart).write_str("$$PCAS02,1000*2E\r\n");
          } else if (rate == "5Hz (Normal)") {
            id(gps_uart).write_str("$$PCAS04,1*18\r\n");  // GPS only (faster)
            id(gps_uart).write_str("$$PCAS02,200*18\r\n");
          } else if (rate == "10Hz (High Speed)") {
            id(gps_uart).write_str("$$PCAS04,1*18\r\n");  // GPS only (faster)
            id(gps_uart).write_str("$$PCAS02,100*1F\r\n");
          }
          ESP_LOGI("gps", "Applied GPS rate: %s", rate.c_str());
      - lambda: |-
          id(gps_uart).write_str("$$PCAS06,1*1D\r\n");  // Enable SBAS