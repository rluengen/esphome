# ============================================================
# ESP32-P4-Pico with 8.8" DSI Touch Display
# Based on Waveshare ESP32-P4-ETH 10.1" example
# Modified for 8.8" DSI screen without internet
# ============================================================

substitutions:
  device_name: controller
  friendly_name: Display Controller
  project_name: display-controller
  project_version: "1.0.0"
  log_level: VERBOSE

packages:
  remote_packages:
    url: https://github.com/rluengen/esphome
    ref: main
    refresh: always
    files:
      - path: packages/ota/http_update.yaml

esphome:
  name: ${device_name}
  friendly_name: ${friendly_name}
  on_boot:
    # VERY EARLY (priority 900) - Full panel init sequence BEFORE DSI bus init
    # Following EXACT order from Waveshare esp_lcd_dsi component
    - priority: 900
      then:
        - lambda: |-
            ESP_LOGI("panel", "=== PANEL INIT (priority 900) - Waveshare sequence ===");
            
            // EXACT sequence from Waveshare esp_lcd_dsi.c
            bool ack;
            
            // 1. MCU reset
            ack = id(display_backlight_i2c).write_byte(0xc0, 0x01);
            ESP_LOGI("panel", "1. MCU reset (0xc0=0x01) ACK: %s", ack ? "YES" : "NO");
            
            // 2. TP reset
            ack = id(display_backlight_i2c).write_byte(0xc2, 0x01);
            ESP_LOGI("panel", "2. TP reset (0xc2=0x01) ACK: %s", ack ? "YES" : "NO");
            
            // 3. Init/probe
            ack = id(display_backlight_i2c).write_byte(0xac, 0x01);
            ESP_LOGI("panel", "3. Init (0xac=0x01) ACK: %s", ack ? "YES" : "NO");
            
            // 4. Brightness max (0x00 = max, inverted)
            ack = id(display_backlight_i2c).write_byte(0xab, 0x00);
            ESP_LOGI("panel", "4. Brightness (0xab=0x00) ACK: %s", ack ? "YES" : "NO");
            
            // 5. Apply brightness
            ack = id(display_backlight_i2c).write_byte(0xaa, 0x01);
            ESP_LOGI("panel", "5. Apply brightness (0xaa=0x01) ACK: %s", ack ? "YES" : "NO");
            
            // 6. Enable MIPI power - LAST in the sequence
            ack = id(display_backlight_i2c).write_byte(0xad, 0x01);
            ESP_LOGI("panel", "6. MIPI enable (0xad=0x01) ACK: %s", ack ? "YES" : "NO");
            
            // 7. CRITICAL: 1000ms delay before DSI init (from Waveshare code)
            ESP_LOGI("panel", "Waiting 1000ms for panel to initialize...");
            delay(1000);
            
            ESP_LOGI("panel", "Panel init sequence complete");
    # Late - after display is initialized
    - priority: -100
      then:
        - lambda: |-
            ESP_LOGI("panel", "=== POST-DSI INIT (priority -100) ===");
            ESP_LOGI("panel", "Display should now be active");
        - light.turn_on:
            id: display_backlight
            brightness: 100%
        - logger.log: "Display boot complete"

esp32:
  board: esp32-p4-evboard
  variant: esp32p4
  flash_size: 16MB
  framework:
    type: esp-idf

# esp32_hosted:
#  active_high: true
#  variant: ESP32C6
#  reset_pin: GPIO54
#  cmd_pin: GPIO19
#  clk_pin: GPIO18
#  d0_pin: GPIO14
#  d1_pin: GPIO15
#  d2_pin: GPIO16
#  d3_pin: GPIO17

#packages:
#  remote_packages:
#    url: https://github.com/rluengen/esphome
#    ref: main
#    refresh: always
#    files:
#      - path: packages/common.yaml
#        vars:
#          api_encryption_key: !secret encryption_key
#      - path: packages/network/wifi.yaml
#        vars:
#          wifi_ssid: !secret wifi_ssid
#          wifi_password: !secret wifi_password
#      - path: packages/time/homeassistant.yaml

# Required for MIPI-DSI display
psram:
  mode: hex
  speed: 200MHZ

# LDO for MIPI-DSI PHY - required for display to initialize
esp_ldo:
  - voltage: 2.5V
    channel: 3

logger:
  level: VERY_VERBOSE
  hardware_uart: UART0
  logs:
    # Quiet the noisy ones to see DSI output
    touchscreen: WARN
    gt911: WARN
    i2c.idf: WARN
    component: INFO
    sensor: INFO

# ============================================================
# I2C for GT911 Touchscreen
# ============================================================
# ESP32-P4-Pico pinout:
#   SDA = GPIO7
#   SCL = GPIO8
# ============================================================

i2c:
  sda: GPIO7
  scl: GPIO8
  frequency: 400kHz
  scan: true

# Font for display test
font:
  - file: "gfonts://Roboto"
    id: roboto
    size: 48

# I2C device for backlight control (address 0x45)
i2c_device:
  - address: 0x45
    id: display_backlight_i2c

# ============================================================
# Backlight Control
# ============================================================
# Waveshare DSI displays use I2C for backlight:
#   Register 0xab = brightness (0x00=max, 0xff=off, inverted)
#   Register 0xaa = enable (write 0x01 to apply)
# ============================================================

# Backlight brightness control as a light
output:
  - platform: template
    id: backlight_output
    type: float
    write_action:
      - lambda: |-
          // Write to BOTH brightness registers to cover all panel variants
          uint8_t brightness = (uint8_t)(state * 255);
          uint8_t inverted = 255 - brightness;  // 0xab uses inverted brightness
          
          // ESP32-P4 style (register 0x96, direct 0-255)
          id(display_backlight_i2c).write_byte(0x96, brightness);
          
          // RPi style (register 0xab inverted + 0xaa latch)
          id(display_backlight_i2c).write_byte(0xab, inverted);
          id(display_backlight_i2c).write_byte(0xaa, 0x01);

light:
  - platform: monochromatic
    name: "Display Backlight"
    id: display_backlight
    output: backlight_output
    default_transition_length: 250ms
    restore_mode: ALWAYS_ON

# ============================================================
# MIPI-DSI Display - 8.8" Touch (480x1920)
# ============================================================
# Waveshare 8.8" DSI Touch A specs:
#   Display IC: OTA7290B
#   Touch IC: GT9271 (GT911 compatible)
#   Resolution: 480 x 1920 (portrait)
#   Interface: MIPI-DSI
#
# Timing parameters from Raspberry Pi kernel driver:
#   https://github.com/raspberrypi/linux/blob/rpi-6.6.y/drivers/gpu/drm/panel/panel-waveshare-dsi.c
# ============================================================

display:
  - platform: mipi_dsi
    id: dsi_display
    model: CUSTOM
    rotation: 0  # Start with no rotation for testing
    dimensions:
      width: 480
      height: 1920
    lanes: 2
    color_order: rgb
    # Timing from Raspberry Pi kernel driver panel-waveshare-dsi.c
    # ws_panel_8_8_mode: .clock = 83333 (83.333 MHz)
    # Total H = 480 + 50 + 50 + 50 = 630
    # Total V = 1920 + 20 + 20 + 20 = 1980
    # Refresh rate = 83.333M / (630 * 1980) = ~66.7 Hz
    hsync_front_porch: 50
    hsync_pulse_width: 50
    hsync_back_porch: 50
    vsync_front_porch: 20
    vsync_pulse_width: 20
    vsync_back_porch: 20
    # Try higher pixel clock - 100 MHz
    pclk_frequency: 100000000
    # Lane bit rate: 100MHz * 16bpp / 2 lanes = 800Mbps minimum, use 1200 for margin
    lane_bit_rate: 1200Mbps
    # Keep RGB565 (16-bit)
    color_depth: 16
    pixel_mode: 16bit
    # Minimal DCS init - just Sleep Out and Display On (from Waveshare driver)
    init_sequence:
      - [0x11, 120]  # Sleep out, 120ms delay
      - [0x29, 20]   # Display on, 20ms delay
    # Simple test pattern - bypasses LVGL
    lambda: |-
      // Fill entire screen with red
      it.fill(Color(255, 0, 0));
      // Draw some test text
      it.print(240, 100, id(roboto), Color(255, 255, 255), TextAlign::CENTER, "DISPLAY TEST");
      it.print(240, 200, id(roboto), Color(255, 255, 0), TextAlign::CENTER, "If you see this");
      it.print(240, 300, id(roboto), Color(0, 255, 0), TextAlign::CENTER, "it works!");

# ============================================================
# GT911 Touchscreen - POLLING MODE for debugging
# ============================================================

touchscreen:
  - platform: gt911
    id: dsi_touchscreen
    # NO interrupt_pin - use polling mode to bypass potential interrupt issues
    update_interval: 50ms
    on_touch:
      - logger.log:
          format: "Touch at (%d, %d)"
          args: [touch.x, touch.y]

# Diagnostic: Read GT911 product ID and firmware to verify it's alive
interval:
  - interval: 5s
    then:
      - lambda: |-
          // Read GT911 Product ID (registers 0x8140-0x8143)
          uint8_t product_id[5] = {0};
          uint8_t reg[2] = {0x81, 0x40};  // Big-endian register address
          
          if (id(dsi_touchscreen).write(reg, 2, false) == i2c::ERROR_OK) {
            if (id(dsi_touchscreen).read(product_id, 4) == i2c::ERROR_OK) {
              product_id[4] = 0;
              ESP_LOGI("gt911_diag", "Product ID: %s", product_id);
            } else {
              ESP_LOGE("gt911_diag", "Failed to read product ID");
            }
          } else {
            ESP_LOGE("gt911_diag", "Failed to write register address");
          }
          
          // Also check panel MCU status
          uint8_t status = 0;
          id(display_backlight_i2c).read_byte(0x80, &status);
          ESP_LOGI("panel_diag", "Panel MCU status (0x80): 0x%02X", status);

# ============================================================
# LVGL Graphics - DISABLED FOR TESTING
# ============================================================
# Uncomment below once display is confirmed working

# lvgl:
#   displays:
#     - dsi_display
#   touchscreens:
#     - dsi_touchscreen
#   color_depth: 16
#   buffer_size: 100%
#   byte_order: little_endian
#   on_idle:
#     - timeout: 30s
#       then:
#         - logger.log: "Display idle timeout"
#   pages:
#     - id: main_page
#       skip: false
#       bg_color: 0xFF0000  # Bright RED background - very visible
#       bg_opa: cover
#       widgets:
#         - label:
#             text: "ESP32-P4 DISPLAY TEST"
#             align: CENTER
#             text_color: 0xFFFFFF  # White text
#             text_font: montserrat_48  # Larger font
#         - label:
#             text: "If you see this, it works!"
#             align: CENTER
#             y: 80
#             text_color: 0xFFFF00  # Yellow text
